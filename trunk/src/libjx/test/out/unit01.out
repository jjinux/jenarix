# unit01.jx
# source: (assert true true)
#   eval: (`assert true true)
true;

# source: (assert false false)
#   eval: (`assert false false)
true;

# source: (assert false
#           (eq true false))
#   eval: (`assert false
#           (`eq true false))
true;

# source: (assert false
#           (eq false true))
#   eval: (`assert false
#           (`eq false true))
true;

# no pre-defined symbols should be returned by symbols 
# source: (assert {}
#           (symbols))
#   eval: (`assert {}
#           (`symbols))
true;

# identity
# source: (assert true
#           (identical null null))
#   eval: (`assert true
#           (`identical null null))
true;

# source: (assert true
#           (identical true true))
#   eval: (`assert true
#           (`identical true true))
true;

# source: (assert true
#           (identical false false))
#   eval: (`assert true
#           (`identical false false))
true;

# source: (assert false
#           (identical 1 1.0))
#   eval: (`assert false
#           (`identical 1 1.0))
true;

# source: (assert true
#           (identical "take" "take"))
#   eval: (`assert true
#           (`identical "take" "take"))
true;

# source: (assert false
#           (identical true 1))
#   eval: (`assert false
#           (`identical true 1))
true;

# source: (assert false
#           (identical true 0))
#   eval: (`assert false
#           (`identical true 0))
true;

# source: (assert false
#           (identical false 1))
#   eval: (`assert false
#           (`identical false 1))
true;

# source: (assert false
#           (identical false 0))
#   eval: (`assert false
#           (`identical false 0))
true;

# source: (assert false
#           (identical a b))
#   eval: (`assert false
#           (`identical (`resolve a)
#             (`resolve b)))
true;

# source: (assert true
#           (identical a a))
#   eval: (`assert true
#           (`identical (`resolve a)
#             (`resolve a)))
true;

# equalityd
# source: (assert false
#           (eq null false))
#   eval: (`assert false
#           (`eq null false))
true;

# source: (assert false
#           (eq null 0))
#   eval: (`assert false
#           (`eq null 0))
true;

# source: (assert false
#           (eq null true))
#   eval: (`assert false
#           (`eq null true))
true;

# source: (assert true
#           (eq false 0))
#   eval: (`assert true
#           (`eq false 0))
true;

# source: (assert true
#           (eq false 0.0))
#   eval: (`assert true
#           (`eq false 0.0))
true;

# source: (assert true
#           (eq true 1))
#   eval: (`assert true
#           (`eq true 1))
true;

# source: (assert true
#           (eq true 1.0))
#   eval: (`assert true
#           (`eq true 1.0))
true;

# source: (assert false
#           (eq false 1))
#   eval: (`assert false
#           (`eq false 1))
true;

# source: (assert false
#           (eq false 1.0))
#   eval: (`assert false
#           (`eq false 1.0))
true;

# source: (assert false
#           (eq true 0))
#   eval: (`assert false
#           (`eq true 0))
true;

# source: (assert false
#           (eq true 0.0))
#   eval: (`assert false
#           (`eq true 0.0))
true;

# source: (assert false
#           (eq false ""))
#   eval: (`assert false
#           (`eq false ""))
true;

# source: (assert false
#           (eq true "1"))
#   eval: (`assert false
#           (`eq true "1"))
true;

# source: (assert false
#           (eq false a))
#   eval: (`assert false
#           (`eq false
#             (`resolve a)))
true;

# source: (assert false
#           (eq false 1))
#   eval: (`assert false
#           (`eq false 1))
true;

# source: (assert false
#           (eq false 1.0))
#   eval: (`assert false
#           (`eq false 1.0))
true;

# source: (assert false
#           (eq false "1"))
#   eval: (`assert false
#           (`eq false "1"))
true;

# source: (assert false
#           (eq false
#             []))
#   eval: (`assert false
#           (`eq false
#             []))
true;

# source: (assert true
#           (not ""))
#   eval: (`assert true
#           (`not ""))
true;

# source: (assert false
#           (not "0"))
#   eval: (`assert false
#           (`not "0"))
true;

# source: (assert true
#           (not []))
#   eval: (`assert true
#           (`not []))
true;

# source: (assert false
#           (not [0]))
#   eval: (`assert false
#           (`not [0]))
true;

# source: (assert true
#           (not {}))
#   eval: (`assert true
#           (`not {}))
true;

# source: (assert false
#           (not {0:0}))
#   eval: (`assert false
#           (`not {0:0}))
true;

# numerical comparison
# source: (assert false
#           (eq 1 0))
#   eval: (`assert false
#           (`eq 1 0))
true;

# source: (assert true
#           (eq 1 1))
#   eval: (`assert true
#           (`eq 1 1))
true;

# source: (assert true
#           (eq 1 1.0))
#   eval: (`assert true
#           (`eq 1 1.0))
true;

# source: (assert false
#           (eq 1.0 2.0))
#   eval: (`assert false
#           (`eq 1.0 2.0))
true;

# string comparison
# source: (assert true
#           (eq "take" "take"))
#   eval: (`assert true
#           (`eq "take" "take"))
true;

# source: (assert {}
#           (symbols))
#   eval: (`assert {}
#           (`symbols))
true;

# source: (assert null
#           (def fn null _))
#   eval: (`assert null
#           (`def fn null
#             (`resolve _)))
true;

# source: (assert [1]
#           (fn 1))
#   eval: (`assert [1]
#           [ (`resolve fn),1])
true;

# source: (assert null
#           (del fn))
#   eval: (`assert null
#           (`del fn))
true;

# source: (assert (raw (fn 1))
#           (fn 1))
#   eval: (`assert (`raw (fn 1))
#           [ (`resolve fn),1])
true;

# source: (assert (raw y) y)
#   eval: (`assert (`raw y)
#           (`resolve y))
true;

# source: (assert null
#           (def fn null
#             (set y _)))
#   eval: (`assert null
#           (`def fn null
#             (`set y
#               (`resolve _))))
true;

# source: (assert null
#           (fn))
#   eval: (`assert null
#           [ (`resolve fn)])
true;

# source: (assert y
#           [])
#   eval: (`assert (`resolve y)
#           [])
true;

# source: (assert null
#           (fn 9))
#   eval: (`assert null
#           [ (`resolve fn),9])
true;

# source: (assert y
#           [9])
#   eval: (`assert (`resolve y)
#           [9])
true;

# source: (assert null
#           (del y))
#   eval: (`assert null
#           (`del y))
true;

# source: (assert null
#           (del fn))
#   eval: (`assert null
#           (`del fn))
true;

# source: (assert {}
#           (symbols))
#   eval: (`assert {}
#           (`symbols))
true;

# functions with {} args use their own private namespace
# with the _ identifier for the payload 
# source: (assert {}
#           (symbols))
#   eval: (`assert {}
#           (`symbols))
true;

# source: (assert null
#           (def fn {}
#             (set y_)))
#   eval: (`assert null
#           (`def fn {}
#             (`set y_)))
true;

# source: (assert (raw y) y)
#   eval: (`assert (`raw y)
#           (`resolve y))
true;

# source: (assert null
#           (del fn))
#   eval: (`assert null
#           (`del fn))
true;

# functions with single ident args use their own private namespace 
# but receive the entire payload in one symbol
# functions with [ident ...] args have only positional arguments
# functions with [[ident ...],{ident:default,...}] have both a keyword
# -based default (namespace) and take optional positional args.
#
# Jason's JXON Test Book
#
#############################################################################
#
# 1.0  Simple types: boolean & existance
#
##############################################################################
# source: true
#   eval: true
true;

# source: (not false)
#   eval: (`not false)
true;

# source: (eq true true)
#   eval: (`eq true true)
true;

# source: (eq null null)
#   eval: (`eq null null)
true;

# source: (eq false false)
#   eval: (`eq false false)
true;

# source: (not (eq false true))
#   eval: (`not (`eq false true))
true;

# source: (not (eq false null))
#   eval: (`not (`eq false null))
true;

# source: (not (eq true null))
#   eval: (`not (`eq true null))
true;

# source: (not (eq null ""))
#   eval: (`not (`eq null ""))
true;

# source: (not (eq true ""))
#   eval: (`not (`eq true ""))
true;

# source: (not (eq false ""))
#   eval: (`not (`eq false ""))
true;

# source: (not (eq null
#             []))
#   eval: (`not (`eq null
#             []))
true;

# source: (not (eq true
#             []))
#   eval: (`not (`eq true
#             []))
true;

# source: (not (eq false
#             []))
#   eval: (`not (`eq false
#             []))
true;

# source: (not (eq null -1))
#   eval: (`not (`eq null -1))
true;

# source: (not (eq null 0))
#   eval: (`not (`eq null 0))
true;

# source: (not (eq null 1))
#   eval: (`not (`eq null 1))
true;

# source: (not (eq null 100000.0))
#   eval: (`not (`eq null 100000.0))
true;

##############################################################################
#
# 1.1 -- Simple Numeric Types
#
##############################################################################
# 1.1.1 Numerical In/equality
# source: (eq 1 1)
#   eval: (`eq 1 1)
true;

# source: (not (eq 1 2))
#   eval: (`not (`eq 1 2))
true;

# source: (not (eq -1 1))
#   eval: (`not (`eq -1 1))
true;

# source: (eq 1.1 1.1)
#   eval: (`eq 1.1 1.1)
true;

# source: (not (eq 1.1 1.0))
#   eval: (`not (`eq 1.1 1.0))
true;

# source: (not (eq 1.1 1))
#   eval: (`not (`eq 1.1 1))
true;

# 1.1.2 -- Numerical ordering
# 1.1.2.1 -- less than or equal: le
# source: (le 1 2)
#   eval: (`le 1 2)
true;

# source: (le 1.1 1.2)
#   eval: (`le 1.1 1.2)
true;

# source: (le -1 10)
#   eval: (`le -1 10)
true;

# 1.1.2.2 -- gt
# source: (gt 2 1)
#   eval: (`gt 2 1)
true;

# source: (gt 2.2 1.1)
#   eval: (`gt 2.2 1.1)
true;

# source: (gt 10000.0 1000.0)
#   eval: (`gt 10000.0 1000.0)
true;

# 1.1.2.3 -- lt
# source: (lt 1 2)
#   eval: (`lt 1 2)
true;

# source: (lt 10000.0 100000.0)
#   eval: (`lt 10000.0 100000.0)
true;

# source: (lt -1 1)
#   eval: (`lt -1 1)
true;

# source: (lt -1 0)
#   eval: (`lt -1 0)
true;

# 1.1.2.4 -- ge
# source: (ge 3 1)
#   eval: (`ge 3 1)
true;

# source: (ge 3 -1)
#   eval: (`ge 3 -1)
true;

# source: (ge 1.3 1.2)
#   eval: (`ge 1.3 1.2)
true;

# source: (ge 10000.0 100.0)
#   eval: (`ge 10000.0 100.0)
true;

# 1.1.3 -- operations on numbers
# 1.1.3.1 -- addition
# source: (eq (add 1 1) 2)
#   eval: (`eq (`add 1 1) 2)
true;

# source: (eq (add -1 1) 0)
#   eval: (`eq (`add -1 1) 0)
true;

# source: (eq (add 1.0 1.0) 2.0)
#   eval: (`eq (`add 1.0 1.0) 2.0)
true;

# source: (eq (add 1.0 1.0) 2)
#   eval: (`eq (`add 1.0 1.0) 2)
true;

# source: (eq (add 1000.0 1000.0) 2000.0)
#   eval: (`eq (`add 1000.0 1000.0) 2000.0)
true;

# source: (eq (add 100 -200) -100)
#   eval: (`eq (`add 100 -200) -100)
true;

# 1.1.3.2 -- subtraction
# source: (eq (sub 1 1) 0)
#   eval: (`eq (`sub 1 1) 0)
true;

# source: (eq (sub 1 1) 0.0)
#   eval: (`eq (`sub 1 1) 0.0)
true;

# source: (eq (sub 200 100) 100)
#   eval: (`eq (`sub 200 100) 100)
true;

# source: (eq (sub -100 -200) 100)
#   eval: (`eq (`sub -100 -200) 100)
true;

# source: (eq (sub 100 -200) 300)
#   eval: (`eq (`sub 100 -200) 300)
true;

# source: (eq (sub 400 200) 200)
#   eval: (`eq (`sub 400 200) 200)
true;

# source: (eq (sub 2000.0 1000.0) 1000.0)
#   eval: (`eq (`sub 2000.0 1000.0) 1000.0)
true;

# 1.1.3.3 -- mult
# source: (eq (mul 2 2) 4)
#   eval: (`eq (`mul 2 2) 4)
true;

# source: (eq (mul -2 2) -4)
#   eval: (`eq (`mul -2 2) -4)
true;

# source: (eq (mul 0.5 0.5) 0.25)
#   eval: (`eq (`mul 0.5 0.5) 0.25)
true;

# source: (eq (mul 1 0) 0)
#   eval: (`eq (`mul 1 0) 0)
true;

# source: (eq (mul 1 0) 0.0)
#   eval: (`eq (`mul 1 0) 0.0)
true;

# source: (eq (mul 1 0) 0)
#   eval: (`eq (`mul 1 0) 0)
true;

# source: (eq (mul 1.0 -4) -4)
#   eval: (`eq (`mul 1.0 -4) -4)
true;

# source: (eq (mul 0 0) 0)
#   eval: (`eq (`mul 0 0) 0)
true;

# source: (eq (mul 100.0 100.0) 10000.0)
#   eval: (`eq (`mul 100.0 100.0) 10000.0)
true;

# 1.1.3.4 -- div
# source: (eq (div 2 1) 2)
#   eval: (`eq (`div 2 1) 2)
true;

# source: (eq (div -100 2) -50)
#   eval: (`eq (`div -100 2) -50)
true;

# source: (eq (div -10 -2) 5)
#   eval: (`eq (`div -10 -2) 5)
true;

# 1.1.3.5 -- mod
# source: (eq (mod 4 2) 0)
#   eval: (`eq (`mod 4 2) 0)
true;

# source: (eq (mod 3 2) 1)
#   eval: (`eq (`mod 3 2) 1)
true;

##############################################################################
#
# 1.2 Simple Strings
#
##############################################################################
# 1.2.1 Single quoted
# source: (eq "A" "A")
#   eval: (`eq "A" "A")
true;

# source: (not (eq "A" "a"))
#   eval: (`not (`eq "A" "a"))
true;

# 1.2.2 Case sensitivity
# source: (not (eq "Foo" "foo"))
#   eval: (`not (`eq "Foo" "foo"))
true;

# true
# source: (eq "FoO" "FoO")
#   eval: (`eq "FoO" "FoO")
true;

##############################################################################
#
# 1.3 Containers
#
##############################################################################
#
# 1.3.1 -- lists
# source: (eq []
#           [])
#   eval: (`eq []
#           [])
true;

# source: (eq []
#           [])
#   eval: (`eq []
#           [])
true;

# source: (not (eq []
#             [1]))
#   eval: (`not (`eq []
#             [1]))
true;

# source: (not (eq [-2]
#             []))
#   eval: (`not (`eq [-2]
#             []))
true;

# source: (eq (range 10)
#           (range 10))
#   eval: (`eq (`range 10)
#           (`range 10))
true;

# 1.3.2 -- nested
# source: (eq [ [], []]
#           [ [], []])
#   eval: (`eq [ [], []]
#           [ [], []])
true;

# source: (eq [ [], []]
#           [ [], []])
#   eval: (`eq [ [], []]
#           [ [], []])
true;

# source: (eq [ [], []]
#           [ [], []])
#   eval: (`eq [ [], []]
#           [ [], []])
true;

# source: (not (eq [ [1], []]
#             [ [], [1]]))
#   eval: (`not (`eq [ [1], []]
#             [ [], [1]]))
true;

# end Jason's stuff
# primitives and dictionarys are passed through unmodified
# source: (assert 0 0)
#   eval: (`assert 0 0)
true;

# source: (assert -1 -1)
#   eval: (`assert -1 -1)
true;

# source: (assert 1 1)
#   eval: (`assert 1 1)
true;

# source: (assert 0.0 0.0)
#   eval: (`assert 0.0 0.0)
true;

# source: (assert 1.0 1.0)
#   eval: (`assert 1.0 1.0)
true;

# source: (assert -1.0 -1.0)
#   eval: (`assert -1.0 -1.0)
true;

# source: (assert "hi world" "hi world")
#   eval: (`assert "hi world" "hi world")
true;

# source: (assert identify identify)
#   eval: (`assert (`resolve identify)
#           (`resolve identify))
true;

# source: (assert {} {})
#   eval: (`assert {} {})
true;

# source: (assert {1:2} {1:2})
#   eval: (`assert {1:2} {1:2})
true;

# source: (assert {1:2,3:4} {1:2,3:4})
#   eval: (`assert {1:2,3:4} {1:2,3:4})
true;

# top-level lists are iterated -- only the last element is returned
# source: (assert {1: [2, 3]} {1: [2, 3]})
#   eval: (`assert {1: [2, 3]} {1: [2, 3]})
true;

# source: (assert []
#           [])
#   eval: (`assert []
#           [])
true;

# source: (assert [ []]
#           [ []])
#   eval: (`assert [ []]
#           [ []])
true;

# lists with identifiers which resolve to code are executed
# source: (assert [ [1, 2]]
#           [ [1, 2]])
#   eval: (`assert [ [1, 2]]
#           [ [1, 2]])
true;

# source: (assert null
#           (set x 1))
#   eval: (`assert null
#           (`set x 1))
true;

# source: (assert 1
#           (get x))
#   eval: (`assert 1
#           (`get x))
true;

# source: (assert null
#           (set x 2))
#   eval: (`assert null
#           (`set x 2))
true;

# source: (assert 2
#           (get x))
#   eval: (`assert 2
#           (`get x))
true;

# type promotion is in
# source: (assert 3
#           (add 1 2))
#   eval: (`assert 3
#           (`add 1 2))
true;

# source: (assert 3.0
#           (add 1 2.0))
#   eval: (`assert 3.0
#           (`add 1 2.0))
true;

# source: (assert 2
#           (add true true))
#   eval: (`assert 2
#           (`add true true))
true;

# source: (assert 0
#           (sub true true))
#   eval: (`assert 0
#           (`sub true true))
true;

# we have looping constructs
# source: (assert 1
#           (sub true false))
#   eval: (`assert 1
#           (`sub true false))
true;

# source: (assert null
#           (set a 10))
#   eval: (`assert null
#           (`set a 10))
true;

# source: (assert null
#           (set b
#             []))
#   eval: (`assert null
#           (`set b
#             []))
true;

# source: (assert null
#           (set c {}))
#   eval: (`assert null
#           (`set c {}))
true;

# while loop
# source: (assert 0
#           (size (get b)))
#   eval: (`assert 0
#           (`size (`get b)))
true;

# source: (assert null
#           (while (get a)
#             [ (append b
#                 (get a)), (set c
#                 (get a) 1),
#               (set a
#                 (sub (get a) 1))]))
#   eval: (`assert null
#           (`while (`get a)
#             [ (`append b
#                 (`get a)), (`set c
#                 (`get a) 1),
#               (`set a
#                 (`sub (`get a) 1))]))
true;

# source: (assert [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
#           (get b))
#   eval: (`assert [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
#           (`get b))
true;

# hash comparison (order-independent of course)
# source: (assert null
#           (output c))
#   eval: (`assert null
#           (`output (`resolve c)))
{2:1,10:1,4:1,8:1,3:1,9:1,6:1,1:1,7:1,5:1};
true;

# source: (assert {2:1,4:1,10:1,8:1,3:1,1:1,6:1,9:1,5:1,7:1}
#           (get c))
#   eval: (`assert {2:1,4:1,10:1,8:1,3:1,1:1,6:1,9:1,5:1,7:1}
#           (`get c))
true;

# source: (assert 10
#           (size (get b)))
#   eval: (`assert 10
#           (`size (`get b)))
true;

# source: (assert 10
#           (size (get c)))
#   eval: (`assert 10
#           (`size (`get c)))
true;

# source: (assert null
#           (set b
#             []))
#   eval: (`assert null
#           (`set b
#             []))
true;

# source: (assert null
#           (for (set a 1)
#             (lt (get a) 10)
#             (set a
#               (add (get a) 1))
#             [ (output a), (append b
#                 (get a))]))
#   eval: (`assert null
#           (`for (`set a 1)
#             (`lt (`get a) 10)
#             (`set a
#               (`add (`get a) 1))
#             [ (`output (`resolve a)), (`append b
#                 (`get a))]))
1;
2;
3;
4;
5;
6;
7;
8;
9;
true;

# do loops
# source: (assert [1, 2, 3, 4, 5, 6, 7, 8, 9]
#           (get b))
#   eval: (`assert [1, 2, 3, 4, 5, 6, 7, 8, 9]
#           (`get b))
true;

# source: (assert null
#           (set a 1))
#   eval: (`assert null
#           (`set a 1))
true;

# source: (assert null
#           (do (set a
#               (add 1
#                 (get a)))
#             (lt (get a) 10)))
#   eval: (`assert null
#           (`do (`set a
#               (`add 1
#                 (`get a)))
#             (`lt (`get a) 10)))
true;

# source: (assert 10
#           (get a))
#   eval: (`assert 10
#           (`get a))
true;

# source: (assert null
#           (set a 1))
#   eval: (`assert null
#           (`set a 1))
true;

# source: (assert [ [ [ [null]]]]
#           [ [ [ [ (do (set a
#                       (add 1
#                         (get a)))
#                     (lt (get a) 10))]]]])
#   eval: (`assert [ [ [ [null]]]]
#           [ [ [ [ (`do (`set a
#                       (`add 1
#                         (`get a)))
#                     (`lt (`get a) 10))]]]])
true;

# here's where we convince ourselves that weak (borrowed) references
# [used through as L-values] cannot leak or escape from where they're used.
# first, create a heap object
# source: (assert 10
#           (get a))
#   eval: (`assert 10
#           (`get a))
true;

# now see what happens when we try to get a borrowed reference
# source: (assert null
#           (set x
#             ["-  -  -  -  -  -  -  -"]))
#   eval: (`assert null
#           (`set x
#             ["-  -  -  -  -  -  -  -"]))
true;

# source: (assert ["-  -  -  -  -  -  -  -"] x)
#   eval: (`assert ["-  -  -  -  -  -  -  -"]
#           (`resolve x))
true;

# source: (assert [ ["-  -  -  -  -  -  -  -"]]
#           (x))
#   eval: (`assert [ ["-  -  -  -  -  -  -  -"]]
#           [ (`resolve x)])
true;

# source: (assert [ ["-  -  -  -  -  -  -  -"], ["-  -  -  -  -  -  -  -"]]
#           (x x))
#   eval: (`assert [ ["-  -  -  -  -  -  -  -"], ["-  -  -  -  -  -  -  -"]]
#           [ (`resolve x), (`resolve x)])
true;

# source: (assert [ ["-  -  -  -  -  -  -  -"], [ ["-  -  -  -  -  -  -  -"]]]
#           (x (x)))
#   eval: (`assert [ ["-  -  -  -  -  -  -  -"], [ ["-  -  -  -  -  -  -  -"]]]
#           [ (`resolve x), [ (`resolve x)]])
true;

# source: (assert [ ["-  -  -  -  -  -  -  -"], [ ["-  -  -  -  -  -  -  -"]],
#             [ [ ["-  -  -  -  -  -  -  -"]]]]
#           (x (x)
#             [ (x)]))
#   eval: (`assert [ ["-  -  -  -  -  -  -  -"], [ ["-  -  -  -  -  -  -  -"]],
#             [ [ ["-  -  -  -  -  -  -  -"]]]]
#           [ (`resolve x), [ (`resolve x)],
#             [ [ (`resolve x)]]])
true;

# source: (assert ["-  -  -  -  -  -  -  -"] x)
#   eval: (`assert ["-  -  -  -  -  -  -  -"]
#           (`resolve x))
true;

# source: (assert null
#           (append x 1))
#   eval: (`assert null
#           (`append x 1))
true;

# source: (assert ["-  -  -  -  -  -  -  -",1] x)
#   eval: (`assert ["-  -  -  -  -  -  -  -",1]
#           (`resolve x))
true;

# source: (assert null
#           (append x x))
#   eval: (`assert null
#           (`append x
#             (`resolve x)))
true;

# source: (assert ["-  -  -  -  -  -  -  -",1,
#             ["-  -  -  -  -  -  -  -",1]]
#           (get x))
#   eval: (`assert ["-  -  -  -  -  -  -  -",1,
#             ["-  -  -  -  -  -  -  -",1]]
#           (`get x))
true;

# source: (assert null
#           (append x
#             (get x)))
#   eval: (`assert null
#           (`append x
#             (`get x)))
true;

# source: (assert ["-  -  -  -  -  -  -  -",1,
#             ["-  -  -  -  -  -  -  -",1],
#             ["-  -  -  -  -  -  -  -",1,
#               ["-  -  -  -  -  -  -  -",1]]]
#           (get x))
#   eval: (`assert ["-  -  -  -  -  -  -  -",1,
#             ["-  -  -  -  -  -  -  -",1],
#             ["-  -  -  -  -  -  -  -",1,
#               ["-  -  -  -  -  -  -  -",1]]]
#           (`get x))
true;

# source: (assert null
#           (set y x))
#   eval: (`assert null
#           (`set y
#             (`resolve x)))
true;

# source: (assert ["-  -  -  -  -  -  -  -",1,
#             ["-  -  -  -  -  -  -  -",1],
#             ["-  -  -  -  -  -  -  -",1,
#               ["-  -  -  -  -  -  -  -",1]]]
#           (get y))
#   eval: (`assert ["-  -  -  -  -  -  -  -",1,
#             ["-  -  -  -  -  -  -  -",1],
#             ["-  -  -  -  -  -  -  -",1,
#               ["-  -  -  -  -  -  -  -",1]]]
#           (`get y))
true;

# source: (assert null
#           (del x))
#   eval: (`assert null
#           (`del x))
true;

# scopeless function behavior (arguments go into _)
# source: (assert ["-  -  -  -  -  -  -  -",1,
#             ["-  -  -  -  -  -  -  -",1],
#             ["-  -  -  -  -  -  -  -",1,
#               ["-  -  -  -  -  -  -  -",1]]]
#           (get y))
#   eval: (`assert ["-  -  -  -  -  -  -  -",1,
#             ["-  -  -  -  -  -  -  -",1],
#             ["-  -  -  -  -  -  -  -",1,
#               ["-  -  -  -  -  -  -  -",1]]]
#           (`get y))
true;

# source: (assert null
#           (set a
#             [1, 2, 3, 4]))
#   eval: (`assert null
#           (`set a
#             [1, 2, 3, 4]))
true;

# source: (assert null
#           (def fn null
#             [ (output _), (get (_ 0) 1)]))
#   eval: (`assert null
#           (`def fn null
#             [ (`output (`resolve _)), (`get (_ 0) 1)]))
true;

# container emptyness testing
# source: (assert 2
#           (fn a))
#   eval: (`assert 2
#           [ (`resolve fn), (`resolve a)])
[[1,2,3,4]];
true;

# source: (assert true
#           (test [1,2, {3:4}] true false))
#   eval: (`assert true
#           (`test [1,2, {3:4}] true false))
true;

# source: (assert false
#           (test [] true false))
#   eval: (`assert false
#           (`test [] true false))
true;

# source: (assert true
#           (test {1:2} true false))
#   eval: (`assert true
#           (`test {1:2} true false))
true;

# not this that type of construct does not work because get expects an
# indentifier (simple or compound)
# source: (assert false
#           (test {} true false))
#   eval: (`assert false
#           (`test {} true false))
true;

# source: (assert null
#           (get [1, 2, 3] 1))
#   eval: (`assert null
#           (`get [1, 2, 3] 1))
true;

# source: (assert (unresolved symbols)
#           (unresolved symbols))
#   eval: (`assert [ (`resolve unresolved), (`resolve symbols)]
#           [ (`resolve unresolved), (`resolve symbols)])
true;

# source: (assert null
#           (set a
#             [1.0]))
#   eval: (`assert null
#           (`set a
#             [1.0]))
true;

# source: (assert null
#           (resize a 100 0.5))
#   eval: (`assert null
#           (`resize (`resolve a) 100 0.5))
true;

# source: (assert [1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5] a)
#   eval: (`assert [1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
#           (`resolve a))
true;

# source: (assert 100
#           (size a))
#   eval: (`assert 100
#           (`size (`resolve a)))
true;

# source: (assert (resize a 10))
#   eval: (`assert (`resize (`resolve a) 10))
true;

# source: (assert [1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
#           (get a))
#   eval: (`assert [1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
#           (`get a))
true;

# source: (assert 10
#           (size a))
#   eval: (`assert 10
#           (`size (`resolve a)))
true;

# source: (assert null
#           (set fn
#             (lambda null
#               (add (get (_ 0) 1) 2))))
#   eval: (`assert null
#           (`set fn
#             (`lambda null
#               (`add (`get (_ 0) 1) 2))))
true;

# scopeless functions inherit their environment (dynamic scoping)
# source: (assert 2.5
#           (fn a))
#   eval: (`assert 2.5
#           [ (`resolve fn), (`resolve a)])
true;

# source: (assert null
#           (def test1 null
#             (get x)))
#   eval: (`assert null
#           (`def test1 null
#             (`get x)))
true;

# source: (assert null
#           (set x 3))
#   eval: (`assert null
#           (`set x 3))
true;

# scopefull function with no parameter list
# source: (assert 3
#           (test1))
#   eval: (`assert 3
#           [ (`resolve test1)])
true;

# source: (assert null
#           (def test1 {x:2}
#             (get x)))
#   eval: (`assert null
#           (`def test1 {x:2}
#             (`get x)))
true;

# source: (assert 2
#           (test1))
#   eval: (`assert 2
#           [ (`resolve test1)])
true;

# source: (assert 8
#           (apply (lambda null 8)))
#   eval: (`assert 8
#           (`apply (`lambda null 8)))
true;

# notice how lambda returns the whole expr, unlike def which iterates
# the expr
# source: (assert null
#           (set a 3))
#   eval: (`assert null
#           (`set a 3))
true;

#
# source: (assert [null,9]
#           (apply (lambda null
#               [ (set a 9), (get a)])))
#   eval: (`assert [null,9]
#           (`apply (`lambda null
#               [ (`set a 9), (`get a)])))
true;

# source: (assert null
#           (def vector_add
#             (v0 v1)
#             [ (if (ne (size v0)
#                   (size v1))
#                 [ (output "Vector size mismatch")]
#                 [ (set r
#                     []), (while v0
#                     (append r
#                       (add (shift v0)
#                         (shift v1)))),r])]))
#   eval: (`assert null
#           (`def vector_add
#             (v0 v1)
#             [ (`if (`ne (`size (`resolve v0))
#                   (`size (`resolve v1)))
#                 [ (`output "Vector size mismatch")]
#                 [ (`set r
#                     []), (`while (`resolve v0)
#                     (`append r
#                       (`add (`shift (`resolve v0))
#                         (`shift (`resolve v1))))),
#                   (`resolve r)])]))
true;

# source: (assert [3, 5, 7]
#           (vector_add [1, 2, 3]
#             [2, 3, 4]))
#   eval: (`assert [3, 5, 7]
#           [ (`resolve vector_add), [1, 2, 3],
#             [2, 3, 4]])
true;

# source: (assert 1000
#           (size (vector_add (range 1000)
#               (range 1000))))
#   eval: (`assert 1000
#           (`size [ (`resolve vector_add), (`range 1000),
#               (`range 1000)]))
true;

