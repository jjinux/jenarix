# unit02.jxp -- basic Python unit tests (no threads)
# simple assignment
# parsed: (set a 1)
# source: (set a 1)
#   eval: (`set a 1)
null;

# multiple assignment
# parsed: (map_set (a b)
#           [2, 1])
# source: (map_set (a b)
#           [2, 1])
#   eval: (`map_set (a b)
#           [2, 1])
null;

# parsed: (assert [2, 1]
#           (a b))
# source: (assert [2, 1]
#           (a b))
#   eval: (`assert [2, 1]
#           [ (`resolve a), (`resolve b)])
true;

# parsed: (map_set (a b)
#           (b a))
# source: (map_set (a b)
#           (b a))
#   eval: (`map_set (a b)
#           [ (`resolve b), (`resolve a)])
null;

# parsed: (assert [1, 2]
#           (a b))
# source: (assert [1, 2]
#           (a b))
#   eval: (`assert [1, 2]
#           [ (`resolve a), (`resolve b)])
true;

# we have literals 
# parsed: (set b {3:"some value", 8.4:0, "another key":"another value", "some key": [1, 2, 3]})
# source: (set b {3:"some value", 8.4:0, "another key":"another value", "some key": [1, 2, 3]})
#   eval: (`set b {3:"some value", 8.4:0, "another key":"another value", "some key": [1, 2, 3]})
null;

# parsed: (assert 4
#           (len b))
# source: (assert 4
#           (size b))
#   eval: (`assert 4
#           (`size (`resolve b)))
true;

# REMEMBER, Jenarix uses copy semantics, not reference-taking semantics, so
# parsed: (set d {"some key":"value"})
# source: (set d {"some key":"value"})
#   eval: (`set d {"some key":"value"})
null;

# NOTE: the following is a deep copy, not a reference copy!
# parsed: (set c d)
# source: (set c d)
#   eval: (`set c
#           (`resolve d))
null;

# parsed: (set (c "another key") "another_value")
# source: (set (c "another key") "another_value")
#   eval: (`set (c "another key") "another_value")
null;

# parsed: (print c)
# source: (print c)
#   eval: ( #native_fn`print (`resolve c))
{"some key":"value","another key":"another_value"}
null;

# parsed: (print d)
# source: (print d)
#   eval: ( #native_fn`print (`resolve d))
{"some key":"value"}
null;

# we have print
# parsed: (print "hello Python world!!! Can you hear me?")
# source: (print "hello Python world!!! Can you hear me?")
#   eval: ( #native_fn`print "hello Python world!!! Can you hear me?")
hello Python world!!! Can you hear me?
null;

# we have for loops (simple iterator)
# including multi-variable
# parsed: (foreach b
#           (range 3 8)
#           [ (print b)])
# source: (foreach b
#           (range 3 8)
#           [ (print b)])
#   eval: (`foreach b
#           (`range 3 8)
#           [ ( #native_fn`print (`resolve b))])
3
4
5
6
7
null;

# we have while loops
# parsed: (foreach (a b)
#           (nop [1, 2]
#             [3, 4])
#           [ (print (a b))])
# source: (foreach (a b)
#           (nop [1, 2]
#             [3, 4])
#           [ (print (a b))])
#   eval: (`foreach (a b)
#           (`nop [1, 2]
#             [3, 4])
#           [ ( #native_fn`print [ (`resolve a), (`resolve b)])])
[1,2]
[3,4]
null;

# parsed: (set x 1)
# source: (set x 1)
#   eval: (`set x 1)
null;

# does simple if work?
# parsed: (while (lt x 9)
#           [ (set x
#               (add x 1)), (print x)])
# source: (while (lt x 9)
#           [ (set x
#               (add x 1)), (print x)])
#   eval: (`while (`lt (`resolve x) 9)
#           [ (`set x
#               (`add (`resolve x) 1)), ( #native_fn`print (`resolve x))])
2
3
4
5
6
7
8
9
null;

# we have cascading IF statements
# parsed: (if 0
#           [ (print "hi")]
#           [ (print 1234)])
# source: (if 0
#           [ (print "hi")]
#           [ (print 1234)])
#   eval: (`if 0
#           [ ( #native_fn`print "hi")]
#           [ ( #native_fn`print 1234)])
1234
null;

# we have functions
# parsed: (if 0
#           [ (print "hi")] 0
#           [ (print "who")] 1
#           [ (print "wow")]
#           [ (print 1234)])
# source: (if 0
#           [ (print "hi")] 0
#           [ (print "who")] 1
#           [ (print "wow")]
#           [ (print 1234)])
#   eval: (`if 0
#           [ ( #native_fn`print "hi")] 0
#           [ ( #native_fn`print "who")] 1
#           [ ( #native_fn`print "wow")]
#           [ ( #native_fn`print 1234)])
wow
null;

# parsed: (def fn
#           (a b)
#           [ (print ["The sum of",a,"and",b,"is",
#                 (add a b)])])
# source: (def fn
#           (a b)
#           [ (print ["The sum of",a,"and",b,"is",
#                 (add a b)])])
#   eval: (`def fn
#           (a b)
#           [ ( #native_fn`print ["The sum of", (`resolve a),"and",
#                 (`resolve b),"is",
#                 (`add (`resolve a)
#                   (`resolve b))])])
null;

# parsed: (fn 1 2)
# source: (fn 1 2)
#   eval: [ (`resolve fn),1,2]
["The sum of",1,"and",2,"is",3]
null;

# parsed: (fn 3 6)
# source: (fn 3 6)
#   eval: [ (`resolve fn),3,6]
["The sum of",3,"and",6,"is",9]
null;

# we have map / lambda
# parsed: (print (map (lambda (x)
#               (mul x x))
#             (range 10)))
# source: (print (map (lambda (x)
#               (mul x x))
#             (range 10)))
#   eval: ( #native_fn`print (`map (`lambda (x)
#               (`mul (`resolve x)
#                 (`resolve x)))
#             (`range 10)))
[0,1,4,9,16,25,36,49,64,81]
null;

# but we're still missing a lot of stuff...
# in particular...
# keyword arguments
# list comphrehensions
# nested loops
# parsed: (set a 5)
# source: (set a 5)
#   eval: (`set a 5)
null;

# parsed: (set b 5)
# source: (set b 5)
#   eval: (`set b 5)
null;

# parsed: (set c 5)
# source: (set c 5)
#   eval: (`set c 5)
null;

# parsed: (while a
#           [ (set a
#               (sub a 1)), (set b a),
#             (while b
#               [ (set c b), (set b
#                   (sub b 1)),
#                 (while c
#                   [ (set c
#                       (sub c 1)), (print (a b c))]),null,
#                 (set a 0)]),
#             (print b),
#             (if 1
#               (true))])
# source: (while a
#           [ (set a
#               (sub a 1)), (set b a),
#             (while b
#               [ (set c b), (set b
#                   (sub b 1)),
#                 (while c
#                   [ (set c
#                       (sub c 1)), (print (a b c))]),null,
#                 (set a 0)]),
#             (print b),
#             (if 1
#               [true])])
#   eval: (`while (`resolve a)
#           [ (`set a
#               (`sub (`resolve a) 1)), (`set b
#               (`resolve a)),
#             (`while (`resolve b)
#               [ (`set c
#                   (`resolve b)), (`set b
#                   (`sub (`resolve b) 1)),
#                 (`while (`resolve c)
#                   [ (`set c
#                       (`sub (`resolve c) 1)), ( #native_fn`print [ (`resolve a), (`resolve b),
#                         (`resolve c)])]),null,
#                 (`set a 0)]),
#             ( #native_fn`print (`resolve b)),
#             (`if 1
#               [true])])
[4,3,3]
[4,3,2]
[4,3,1]
[4,3,0]
[0,2,2]
[0,2,1]
[0,2,0]
[0,1,1]
[0,1,0]
[0,0,0]
0
true;

# parsed: (print b)
# source: (print b)
#   eval: ( #native_fn`print (`resolve b))
0
null;

# parsed: (set c 2)
# source: (set c 2)
#   eval: (`set c 2)
null;

# parsed: (print c)
# source: (print c)
#   eval: ( #native_fn`print (`resolve c))
2
null;

# parsed: (foreach a
#           [1, 2]
#           [ (foreach b
#               [5, 6]
#               [ (foreach c
#                   [7, 6]
#                   [ (print (a b c))])])])
# source: (foreach a
#           [1, 2]
#           [ (foreach b
#               [5, 6]
#               [ (foreach c
#                   [7, 6]
#                   [ (print (a b c))])])])
#   eval: (`foreach a
#           [1, 2]
#           [ (`foreach b
#               [5, 6]
#               [ (`foreach c
#                   [7, 6]
#                   [ ( #native_fn`print [ (`resolve a), (`resolve b),
#                         (`resolve c)])])])])
[1,5,7]
[1,5,6]
[1,6,7]
[1,6,6]
[2,5,7]
[2,5,6]
[2,6,7]
[2,6,6]
null;

# parsed: (set a 0)
# source: (set a 0)
#   eval: (`set a 0)
null;

# parsed: (set b 0)
# source: (set b 0)
#   eval: (`set b 0)
null;

# parsed: (set c 0)
# source: (set c 0)
#   eval: (`set c 0)
null;

# parsed: (while a
#           [ (while b
#               [ (while c
#                   [ []])])])
# source: (while a
#           [ (while b
#               [ (while c
#                   [ []])])])
#   eval: (`while (`resolve a)
#           [ (`while (`resolve b)
#               [ (`while (`resolve c)
#                   [ []])])])
null;

# ordinary symbols
# parsed: (if 0
#           [ []])
# source: (if 0
#           [ []])
#   eval: (`if 0
#           [ []])
null;

# parsed: (def fn null
#           [ (print [1, 2, 3])])
# source: (def fn null
#           [ (print [1, 2, 3])])
#   eval: (`def fn null
#           [ ( #native_fn`print [1, 2, 3])])
null;

# parsed: (set a fn)
# source: (set a fn)
#   eval: (`set a
#           (`resolve fn))
null;

# parsed: (a)
# source: (a)
#   eval: [ (`resolve a)]
[1,2,3]
null;

# parsed: (del a)
# source: (del a)
#   eval: (`del a)
null;

# this behavior is a little bizzare: calling an unbound (simple)
# symbol gives that symbol as the first member of an (unevalued) JXON
# invocation frame (symbol plus args)
# parsed: (assert (nop a 1 2)
#           (a 1 2))
# source: (assert (nop a 1 2)
#           (a 1 2))
#   eval: (`assert (`nop (`resolve a) 1 2)
#           [ (`resolve a),1,2])
true;

# whereas with a compound symbol, we get null with the arguments
# parsed: (assert (nop null 3 4)
#           (a.b 3 4))
# source: (assert (nop null 3 4)
#           (a.b 3 4))
#   eval: (`assert [null,3,4]
#           [ (`resolve (a b)),3,4])
true;

# entities and attributes
# parsed: (assert (entity Base null
#             [1, 2, 3] {x:"X", y:"Y"}) Base)
# source: (assert (entity Base null
#             [1, 2, 3] {x:"X", y:"Y"}) Base)
#   eval: (`assert (`entity Base null
#             [1, 2, 3] {x:"X", y:"Y"})
#           (`resolve Base))
true;

# "new" creates entity instances which have
# their own content, but inherit attributes
# parsed: (set a
#           (new Base))
# source: (set a
#           (new Base))
#   eval: (`set a
#           (`new (`resolve Base)))
null;

# parsed: (set b
#           (new Base))
# source: (set b
#           (new Base))
#   eval: (`set b
#           (`new (`resolve Base)))
null;

# parsed: (print (a b))
# source: (print (a b))
#   eval: ( #native_fn`print [ (`resolve a), (`resolve b)])
[[$Base,[1,2,3]],[$Base,[1,2,3]]]
null;

# parsed: (print (a.x b.x))
# source: (print (a.x b.x))
#   eval: ( #native_fn`print [ (`resolve (a x)), (`resolve (b x))])
["X","X"]
null;

# setting attributes can be done through simple assignment
# parsed: (set a.x 2)
# source: (set a.x 2)
#   eval: (`set (a x) 2)
null;

# parsed: (print (a.x b.x))
# source: (print (a.x b.x))
#   eval: ( #native_fn`print [ (`resolve (a x)), (`resolve (b x))])
[2,"X"]
null;

# parsed: (print (a b))
# source: (print (a b))
#   eval: ( #native_fn`print [ (`resolve a), (`resolve b)])
[[$Base,[1,2,3],{x:2}],[$Base,[1,2,3]]]
null;

# instance content is accessed via the zero-length symbol (trailing dot)
# parsed: (print a.)
# source: (print a.)
#   eval: ( #native_fn`print (`resolve (a .)))
[1,2,3]
null;

# and can be acted upon using using builtin functions
# parsed: (print (a..size))
# source: (print (a..size))
#   eval: ( #native_fn`print [ (`resolve (a . size))])
3
null;

# instance content can be assigned directly
# parsed: (set a.
#           [2, 3, 4])
# source: (set a.
#           [2, 3, 4])
#   eval: (`set (a .)
#           [2, 3, 4])
null;

# parsed: (print a.)
# source: (print a.)
#   eval: ( #native_fn`print (`resolve (a .)))
[2,3,4]
null;

# and can be manipulated
# parsed: (append a. 5)
# source: (append a. 5)
#   eval: (`append (`resolve (a .)) 5)
null;

# parsed: (print a.)
# source: (print a.)
#   eval: ( #native_fn`print (`resolve (a .)))
[2,3,4,5]
null;

# parsed: (a..reverse)
# source: (a..reverse)
#   eval: [ (`resolve (a . reverse))]
null;

# parsed: (print a.)
# source: (print a.)
#   eval: ( #native_fn`print (`resolve (a .)))
[5,4,3,2]
null;

# parsed: (assert 4
#           (a..take 1))
# source: (assert 4
#           (a..take 1))
#   eval: (`assert 4
#           [ (`resolve (a . take)),1])
true;

# parsed: (print a.)
# source: (print a.)
#   eval: ( #native_fn`print (`resolve (a .)))
[5,3,2]
null;

# derived entities can redefine attributes and include their own
# content prototype
# parsed: (assert (entity Deriv Base
#             [3, 4, 5] {x:"XX", z:"Z"}) Deriv)
# source: (assert (entity Deriv Base
#             [3, 4, 5] {x:"XX", z:"Z"}) Deriv)
#   eval: (`assert (`entity Deriv
#             (`resolve Base)
#             [3, 4, 5] {x:"XX", z:"Z"})
#           (`resolve Deriv))
true;

# parsed: (set a
#           (new Deriv))
# source: (set a
#           (new Deriv))
#   eval: (`set a
#           (`new (`resolve Deriv)))
null;

# parsed: (print (a.x a.y a.z))
# source: (print (a.x a.y a.z))
#   eval: ( #native_fn`print [ (`resolve (a x)), (`resolve (a y)),
#             (`resolve (a z))])
["XX","Y","Z"]
null;

# parsed: (set a.z "ZZZ")
# source: (set a.z "ZZZ")
#   eval: (`set (a z) "ZZZ")
null;

# parsed: (print (a.x a.y a.z))
# source: (print (a.x a.y a.z))
#   eval: ( #native_fn`print [ (`resolve (a x)), (`resolve (a y)),
#             (`resolve (a z))])
["XX","Y","ZZZ"]
null;

# parsed: (assert "ZZZ" a.z)
# source: (assert "ZZZ" a.z)
#   eval: (`assert "ZZZ"
#           (`resolve (a z)))
true;

# parsed: (set b
#           (new Deriv))
# source: (set b
#           (new Deriv))
#   eval: (`set b
#           (`new (`resolve Deriv)))
null;

# notice how content is independent -- copied, not inherited
# parsed: (a..append 3)
# source: (a..append 3)
#   eval: [ (`resolve (a . append)),3]
null;

# parsed: (print (a. b.))
# source: (print (a. b.))
#   eval: ( #native_fn`print [ (`resolve (a .)), (`resolve (b .))])
[[3,4,5,3],[3,4,5]]
null;

# entity definitions with methods 
# parsed: (assert (entity Base null
#             [1, 2, 3] {fill_content: (lambda (self cnt what)
#               (set self.
#                 (fill cnt what))), get_content: (lambda (self) self.), reverse_content: (lambda (self)
#               (self..reverse))}) Base)
# source: (assert (entity Base null
#             [1, 2, 3] {fill_content: (lambda (self cnt what)
#               (set self.
#                 (fill cnt what))), get_content: (lambda (self) self.), reverse_content: (lambda (self)
#               (self..reverse))}) Base)
#   eval: (`assert (`entity Base null
#             [1, 2, 3] {fill_content: (`lambda (self cnt what)
#               (`set (self .)
#                 (`fill (`resolve cnt)
#                   (`resolve what)))), get_content: (`lambda (self)
#               (`resolve (self .))), reverse_content: (`lambda (self)
#               [ (`resolve (self . reverse))])})
#           (`resolve Base))
true;

# parsed: (set a
#           (new Base))
# source: (set a
#           (new Base))
#   eval: (`set a
#           (`new (`resolve Base)))
null;

# parsed: (print (a.get_content))
# source: (print (a.get_content))
#   eval: ( #native_fn`print [ (`resolve (a get_content))])
[1,2,3]
null;

# parsed: (set a.
#           [4, 5, 6])
# source: (set a.
#           [4, 5, 6])
#   eval: (`set (a .)
#           [4, 5, 6])
null;

# parsed: (print (a.get_content))
# source: (print (a.get_content))
#   eval: ( #native_fn`print [ (`resolve (a get_content))])
[4,5,6]
null;

# parsed: (a.reverse_content)
# source: (a.reverse_content)
#   eval: [ (`resolve (a reverse_content))]
null;

# parsed: (print (a.get_content))
# source: (print (a.get_content))
#   eval: ( #native_fn`print [ (`resolve (a get_content))])
[6,5,4]
null;

# parsed: (a.fill_content 8 5)
# source: (a.fill_content 8 5)
#   eval: [ (`resolve (a fill_content)),8,5]
null;

# parsed: (print (a.get_content))
# source: (print (a.get_content))
#   eval: ( #native_fn`print [ (`resolve (a get_content))])
[5,5,5,5,5,5,5,5]
null;

# parsed: (del a)
# source: (del a)
#   eval: (`del a)
null;

# one key thing to understand about jenarix is that dot notation
# cannot currently be used on intermedate results: a.b().d.e must
# instead be split up into two commands which involve binding of a
# temporary symbol which is then itself used with dot notation
# parsed: (set a {b: (lambda null {d: {e: [1, 2]}})})
# source: (set a {b: (lambda null {d: {e: [1, 2]}})})
#   eval: (`set a {b: (`lambda null {d: {e: [1, 2]}})})
null;

# parsed: (set tmp
#           (a.b))
# source: (set tmp
#           (a.b))
#   eval: (`set tmp
#           [ (`resolve (a b))])
null;

# parsed: (print tmp.d.e)
# source: (print tmp.d.e)
#   eval: ( #native_fn`print (`resolve (tmp d e)))
[1,2]
null;

# this requirement arises from the Jenarix requirement that all
# resolved value references must refer to object which lie somewhere
# on the directed acyclic graph of the current scope (and are thus
# persistent)
# parsed: null
# source: null
#   eval: null
null;

