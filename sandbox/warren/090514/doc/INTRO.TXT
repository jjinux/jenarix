# This is an introduction to the Jenarix intermediate language JXON

# NOTE: the following examples are intended to be run through ./jxeval
# interactively.  Please try them for yourself!

# Also note that jxv currently requires that each JXON phrase be
# terminated with a semicolon; this requirement may vanish in the
# future.

# JXON is a cross between LISP and JSON semantics.
#
# With respect to JSON, JXON adds two new primitive types (identifiers
# and builtins), adds support for single-quoted strings, allows all
# primitive types to serve as hash keys, treats commas as optional,
# and supports #-delimited single-line comments.
#
# With respect to LISP, JXON phrases are LISP-like symbolic-
# expressions (S-expressions) which the Jenarix runtime is capable of
# creating, transforming, binding, and executing.

# JXON primitives include:

# - the basics: nonexistence, truth, and falsehood.

null;
true;
false;

# - integers

1;
2;
-1;

# - floats

1.0;
-0.25;

# - strings

"double quoted string";
'single quoted string';

# - identifiers

a_simple_identifier;

a.compound.identifier;

# - and builtins (which represent bound entities that cannot be
#   directly input, and are instead created and used at runtime)

*add*;

*fn:my_custom_fn*;

*native_fn:0x123456*;  

# JXON containers include:

# - lists (but with optional commas)

[1,2,3];

[a b c];

[true,2.0,'a'];

[1 0 0
 0 1 0
 0 0 1];

[my_fn arg1,arg2];

[[][][]];

# - and hashes (also with optional commas)

{'a':'b'};

{true:false false:true};

{
 a:b
 b:c
 c:a
};

# JXON containers can be nested to arbitrary levels of complexity,
# just like with JSON

[{'a':1},[{ x:10,y:9}],[[{true:3}[[6],{}] ]  ]];

# So what about programming?  Well, first note that all executing code
# has an associated namespace.  You can set values using set:

[set x 100];

# and recall them using get:

[get x];  

# result: 100

# or merely the symbol itself

x;

# result: 100

# You can of course store containers as well:

[set y [0,0,0]];

y;

# result: [0,0,0]

# And modify them

[append [borrow y] 1];

y;

# result: [0,0,0,1]

[extend [borrow y] [get y]];

y;

# result: [0,0,0,1,0,0,0,1]

# Jenarix function invocations arise from a single magic pattern:
#
# The presence of an identifier in the first position of a list 
# which resolves to a callable function.

# Assuming that f is callable, the the meaning of the following phrase
# is:  function f is invoked with a payload of [f,2]

[f,2];

# Note that this special behavior *only* applies to identifiers located
# in the first position of a list.  Identifiers in all other positions
# are simply resolved like normal.

# THIS IS WHERE WERE PRESENTLY BREAK FROM LISP in a BIG WAY and need to 
# think carefully about whether or not our approach makes sense.

# LISP function evaluations cascade: ((fn) 1 2) will call both fn and
# the function returned by function, and the second call will take 1 2
# as the argument list.  In LISP, a function encountered at the first
# position of a list is ALWAYS a function invocation.  To prevent that,
# use of the quote operator is required.

# In JXON: [[fn] 1 3] merely returns the function as the first entry
# in the surrounding list.  That's because the ONLY automatic function
# invocation in JXON is when an IDENTIFIER in first position RESOLVES
# to a function.  Evaluating a list with a function in first position
# doesn't by itself have any special meaning.  

# To get a secondary evaluation in JSON, you would need to do
# something more like: [apply [fn] [1 2]] or perhaps
# [eval [fn] 1 2 ] 
# behavior instead of requiring quote to disable such behavior

# So a key question for JSON: Does the data-centeric nature of JSON
# combined with our target user community (general scientists --
# not computer scientists) justify this decidedly non-LISP-like behavior?

# Speaking personally, I have never been a big fan of 'quote in LISP...

# Another area of divergenge is the differential behavior of Python 
# lambdas versus LISP lambdas.  LISP lambdas are 100% the equivalent
# of functions whereas Python lambdas are expressions not list of
# statements like a function.

# 
# Control flow

[set x 0];

[if true [set x 1]];

x;

# result: 1

[if false [set x 1] [set x 0]];

x;

# result: 0

# Loops

[set x 10];

[do 
  [
    [output x]
    [set x [sub x 1]]
  ]
  [gt x 5]
];

[set y [2,5,8,10]];

[while y [output [take [borrow y] 0]]];
# output:
2;
5;
8;
10;
# result: null

[for [set x 1] [le x 5] [set x [add x 1]] [output x]];
# output:
1;
2;
3;
4;
5;
# result: null


# Lambda and Apply

[apply [lambda null _] 1.50];

# result: 1.5

[apply [lambda {a:4} [_,a]] 3];

# result: [3,4]

# Functions. 

[def fn1 null 9];

[fn1];

# result: 9

[impl fn1];

# result: [fn1,null,9]

# Note that invoked functions are currently given the entire
# invocation list as the payload, including the unresolved function
# identifier.  We don't yet have a system for describing parameters
# and matching up arguments (though we may not need one at this low
# level)

[def fn2 {a:2} _ ];  

[fn2 arg1 'arg2' {arg3:0}];  

# result: [fn2,arg1,"arg2",{arg3:0}]

[def fn3 null [add 4 [take _ 1]] ];

[fn3 5];

# result: 9

# Usable built-in capabilities at present:

# if (conditional) (then-body) (else-body)

# while (conditional)

# do (body) (conditional)

# for (init) (step) (conditional) (body)

# def (name) (namespace) (code)

# lambda (namespace) (code)

# apply (function) (payload)

# map (function) (list)

# impl (function)

# set (ident) (value)
# set (hash) (key) (value)
# set (list) (index) (value)

# get (ident) 
# get (list) (index)
# get (hash) (key)

# take (ident)
# take (list) (index)
# take (hash) (key)

# del (ident)
# del (list) (index)
# del (hash) (key)

# borrow (ident)   <---- # hopefully this will go away!

# decr (ident)
# incr (ident)

# append (list-ident) (expr)
# pop (list-ident) (expr)

# shift (list-ident) (expr)
# unshift (list-ident) (expr)

# extend (list-ident) (list)
# insert (list-ident) (index) (value)
# resize (list-ident) (size) (fill)
# slice (list-ident) (size) (fill)
# cutout (list-ident) (size) (fill)

# identical (expr) (expr)
# eq (expr) (expr)
# gt (expr) (expr)
# lt (expr) (expr)
# ge (expr) (expr)
# le (expr) (expr)

# output (expr)
# error (expr)

# add (expr) (expr)
# sub (expr) (expr)
# mul (expr) (expr)
# div (expr) (expr)
# mod (expr) (expr)

# and (expr) (expr)
# or  (expr) (expr)

# neg (expr)
# not (expr)

# size (expr)





