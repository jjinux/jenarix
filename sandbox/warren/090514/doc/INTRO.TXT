# This is an introduction to the Jenarix intermediate language JXON,
# which is a JSON-based eXecutable Object Notation.

# NOTE: the following examples are intended to be run through ./jxeval
# interactively.  Please try them for yourself!

# Also note that ./jxeval currently requires that each JXON phrase be
# terminated with a semicolon; this requirement may vanish in the
# future.

# JXON is a cross between LISP and JSON semantics.
#
# With respect to JSON, JXON adds two new primitive types (identifiers
# and builtins), adds support for single-quoted strings, allows all
# primitive types to serve as hash keys, treats commas as optional,
# and supports #-delimited single-line comments.
#

# With respect to LISP, JXON phrases are LISP-like symbolic-
# expressions (S-expressions) which the Jenarix runtime is capable of
# creating, transforming, binding, and executing.  

# JXON primitives include:

# - the basics: nonexistence, truth, and falsehood.

null;
true;
false;

# - integers

1;
2;
-1;

# - floats

1.0;
-0.25;

# - strings

"double quoted string";
'single quoted string';

# - identifiers

a_simple_identifier;

a.compound.identifier;

# - and builtins (which represent bound entities that cannot be
#   directly input, and are instead created and used at runtime)

*add*;

*fn:my_custom_fn*;

*native_fn:0x123456*;  

# JXON containers include:

# - lists (but with optional commas)

[1,2,3];

[a b c];

[true,2.0,'a'];

[1 0 0
 0 1 0
 0 0 1];

[my_fn arg1,arg2];

[[][][]];

# - and hashes (also with optional commas)

{'a':'b',45:23,x:9};

{true:false false:true};

{
 a:b
 b:c
 c:a
};

# JXON containers can be nested to arbitrary levels of complexity,
# just like with JSON

[{'a':1},[{ x:10,y:9}],[[{true:3}[[6],{}] ]  ]];

# So what about programming?  Well, first note that all executing code
# has an associated namespace.  You can set values using set:

[set x 100];

# and recall them using get:

[get x];  

# result: 100

# or merely the symbol itself

x;

# result: 100

# You can of course store containers as well:

[set y [0,0,0]];

y;

# result: [0,0,0]

# And modify them

[append y 1];

y;

# result: [0,0,0,1]

[extend y [get y]];

y;

# result: [0,0,0,1,0,0,0,1]

# Control flow

[set x 0];

[if true [set x 1]];

x;

# result: 1

[if false [set x 1] [set x 0]];

x;

# result: 0

# Loops

[set x 10];

[do 
  [
    [output x]
    [set x [sub x 1]]
  ]
  [gt x 5]
];

[set y [2,5,8,10]];

[while y [output [take y 0]]];
# output:
2;
5;
8;
10;
# result: null

[for [set x 1] [le x 5] [set x [add x 1]] [output x]];
# output:
1;
2;
3;
4;
5;
# result: null


# Lambda and Apply

[apply [lambda null _] 1.50];

# result: 1.5

[apply [lambda {a:4} [_,a]] 3];

# result: [3,4]

# Functions. 

[def fn1 null 9];

[fn1];

# result: 9

[impl fn1];

# result: [fn1,null,9]

# Note that invoked functions are currently given the entire
# invocation list as the payload, including the unresolved function
# identifier.  We don't yet have a system for describing parameters
# and matching up arguments (though we may not need one at this low
# level)

[def fn2 {a:2} _ ];  

[fn2 arg1 'arg2' {arg3:0}];  

# result: [fn2,arg1,"arg2",{arg3:0}]

[def fn3 null [add 4 [take _ 1]] ];

[fn3 5];

# result: 9

# Usable built-in capabilities at present:

# if (conditional) (then-body) (else-body)

# while (conditional)

# do (body) (conditional)

# for (init) (step) (conditional) (body)

# def (name) (namespace) (code)

# lambda (namespace) (code)

# apply (function) (payload)

# call (function) (arg1) (arg2) (arg2)

# map (function) (list)  # process each member using a length-1 argument list (SLOW!)

# impl (function)

# set (ident) (value)
# set (hash) (key) (value)
# set (list) (index) (value)

# get (ident) 
# get (list) (index)
# get (hash) (key)

# take (ident)
# take (list) (index)
# take (hash) (key)

# has (ident)
# has (hash) (key)

# del (ident)
# del (list) (index)
# del (hash) (key)

# decr (ident)
# incr (ident)

# append (list-ident) (expr)
# pop (list-ident) (expr)

# shift (list-ident) (expr)
# unshift (list-ident) (expr)

# extend (list-ident) (list)
# insert (list-ident) (index) (value)
# resize (list-ident) (size) (fill)
# slice (list-ident) (size) (fill)
# cutout (list-ident) (size) (fill)

# identical (expr) (expr)
# eq (expr) (expr)
# gt (expr) (expr)
# lt (expr) (expr)
# ge (expr) (expr)
# le (expr) (expr)

# output (expr)
# error (expr)

# add (expr) (expr)
# sub (expr) (expr)
# mul (expr) (expr)
# div (expr) (expr)
# mod (expr) (expr)

# and (expr) (expr)
# or  (expr) (expr)

# neg (expr)
# not (expr)

# size (expr)

# range (start) (stop) (step)
# fill (count) (withwhat)

# symbols





