# unit01.jx -- basic JXON tests (no threads)
# NOTE (assert arg1) is equivalent to (assert arg1 null)
# source: (assert true true)
#   eval: (`assert true true)
true;

# source: (assert false false)
#   eval: (`assert false false)
true;

# source: (assert false
#           (eq true false))
#   eval: (`assert false
#           (`eq true false))
true;

# source: (assert false
#           (eq false true))
#   eval: (`assert false
#           (`eq false true))
true;

# no pre-defined symbols should be returned by symbols 
# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# identity
# source: (assert true
#           (identical null null))
#   eval: (`assert true
#           (`identical null null))
true;

# source: (assert true
#           (identical true true))
#   eval: (`assert true
#           (`identical true true))
true;

# source: (assert true
#           (identical false false))
#   eval: (`assert true
#           (`identical false false))
true;

# source: (assert false
#           (identical 1 1.0))
#   eval: (`assert false
#           (`identical 1 1.0))
true;

# source: (assert true
#           (identical "take" "take"))
#   eval: (`assert true
#           (`identical "take" "take"))
true;

# source: (assert false
#           (identical true 1))
#   eval: (`assert false
#           (`identical true 1))
true;

# source: (assert false
#           (identical true 0))
#   eval: (`assert false
#           (`identical true 0))
true;

# source: (assert false
#           (identical false 1))
#   eval: (`assert false
#           (`identical false 1))
true;

# source: (assert false
#           (identical false 0))
#   eval: (`assert false
#           (`identical false 0))
true;

# source: (assert false
#           (identical a b))
#   eval: (`assert false
#           (`identical (`resolve a)
#             (`resolve b)))
true;

# source: (assert true
#           (identical a a))
#   eval: (`assert true
#           (`identical (`resolve a)
#             (`resolve a)))
true;

# equality
# source: (assert false
#           (eq null false))
#   eval: (`assert false
#           (`eq null false))
true;

# source: (assert false
#           (eq null 0))
#   eval: (`assert false
#           (`eq null 0))
true;

# source: (assert false
#           (eq null true))
#   eval: (`assert false
#           (`eq null true))
true;

# source: (assert true
#           (eq false 0))
#   eval: (`assert true
#           (`eq false 0))
true;

# source: (assert true
#           (eq false 0.0))
#   eval: (`assert true
#           (`eq false 0.0))
true;

# source: (assert true
#           (eq true 1))
#   eval: (`assert true
#           (`eq true 1))
true;

# source: (assert true
#           (eq true 1.0))
#   eval: (`assert true
#           (`eq true 1.0))
true;

# source: (assert false
#           (eq false 1))
#   eval: (`assert false
#           (`eq false 1))
true;

# source: (assert false
#           (eq false 1.0))
#   eval: (`assert false
#           (`eq false 1.0))
true;

# source: (assert false
#           (eq true 0))
#   eval: (`assert false
#           (`eq true 0))
true;

# source: (assert false
#           (eq true 0.0))
#   eval: (`assert false
#           (`eq true 0.0))
true;

# source: (assert false
#           (eq false ""))
#   eval: (`assert false
#           (`eq false ""))
true;

# source: (assert false
#           (eq true "1"))
#   eval: (`assert false
#           (`eq true "1"))
true;

# source: (assert false
#           (eq false a))
#   eval: (`assert false
#           (`eq false
#             (`resolve a)))
true;

# source: (assert false
#           (eq false 1))
#   eval: (`assert false
#           (`eq false 1))
true;

# source: (assert false
#           (eq false 1.0))
#   eval: (`assert false
#           (`eq false 1.0))
true;

# source: (assert false
#           (eq false "1"))
#   eval: (`assert false
#           (`eq false "1"))
true;

# source: (assert false
#           (eq false
#             []))
#   eval: (`assert false
#           (`eq false
#             []))
true;

# source: (assert true
#           (not ""))
#   eval: (`assert true
#           (`not ""))
true;

# source: (assert false
#           (not "0"))
#   eval: (`assert false
#           (`not "0"))
true;

# source: (assert true
#           (not []))
#   eval: (`assert true
#           (`not []))
true;

# source: (assert false
#           (not [0]))
#   eval: (`assert false
#           (`not [0]))
true;

# source: (assert true
#           (not {}))
#   eval: (`assert true
#           (`not {}))
true;

# source: (assert false
#           (not {0:0}))
#   eval: (`assert false
#           (`not {0:0}))
true;

# numerical comparison
# source: (assert false
#           (eq 1 0))
#   eval: (`assert false
#           (`eq 1 0))
true;

# source: (assert true
#           (eq 1 1))
#   eval: (`assert true
#           (`eq 1 1))
true;

# source: (assert true
#           (eq 1 1.0))
#   eval: (`assert true
#           (`eq 1 1.0))
true;

# source: (assert false
#           (eq 1.0 2.0))
#   eval: (`assert false
#           (`eq 1.0 2.0))
true;

# string comparison
# source: (assert true
#           (eq "take" "take"))
#   eval: (`assert true
#           (`eq "take" "take"))
true;

# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# source: (assert (def fn null _))
#   eval: (`assert (`def fn null
#             (`resolve _)))
true;

# source: (assert [1]
#           (fn 1))
#   eval: (`assert [1]
#           [ (`resolve fn),1])
true;

# source: (assert (del fn))
#   eval: (`assert (`del fn))
true;

# source: (assert (raw (fn 1))
#           (fn 1))
#   eval: (`assert (`raw (fn 1))
#           [ (`resolve fn),1])
true;

# source: (assert (raw y) y)
#   eval: (`assert (`raw y)
#           (`resolve y))
true;

# source: (assert (def fn null
#             (set y _)))
#   eval: (`assert (`def fn null
#             (`set y
#               (`resolve _))))
true;

# source: (assert (fn))
#   eval: (`assert [ (`resolve fn)])
true;

# source: (assert y
#           [])
#   eval: (`assert (`resolve y)
#           [])
true;

# source: (assert (fn 9))
#   eval: (`assert [ (`resolve fn),9])
true;

# source: (assert y
#           [9])
#   eval: (`assert (`resolve y)
#           [9])
true;

# source: (assert (del y))
#   eval: (`assert (`del y))
true;

# source: (assert (del fn))
#   eval: (`assert (`del fn))
true;

# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# basic namespace actions: get, set, has, del, take
# source: (assert (set name 1))
#   eval: (`assert (`set name 1))
true;

# source: (assert 1
#           (get name))
#   eval: (`assert 1
#           (`get name))
true;

# source: (assert true
#           (has name))
#   eval: (`assert true
#           (`has name))
true;

# source: (assert (del name))
#   eval: (`assert (`del name))
true;

# source: (assert name name)
#   eval: (`assert (`resolve name)
#           (`resolve name))
true;

# source: (assert (set name 2))
#   eval: (`assert (`set name 2))
true;

# source: (assert 2
#           (take name))
#   eval: (`assert 2
#           (`take name))
true;

# source: (assert name name)
#   eval: (`assert (`resolve name)
#           (`resolve name))
true;

# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# functions with {} args use their own private namespace
# with the _ identifier for the payload 
# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# source: (assert (def fn {}
#             (set y_)))
#   eval: (`assert (`def fn {}
#             (`set y_)))
true;

# source: (assert (raw y) y)
#   eval: (`assert (`raw y)
#           (`resolve y))
true;

# source: (assert (del fn))
#   eval: (`assert (`del fn))
true;

# ======================================================================
# - LISP-like functional expression definition "defun" and evaluation with a
#   conventional ordinary argument list
# source: (assert (defun my_expr
#             (x y z)
#             (x y z)))
#   eval: (`assert (`defun my_expr
#             (x y z)
#             [ (`resolve x), (`resolve y),
#               (`resolve z)]))
true;

# - Python-like code definition "def" and evaluation using an ordinary
#   argument list.
# source: (assert [1, 2, 3]
#           (my_expr 1 2 3))
#   eval: (`assert [1, 2, 3]
#           [ (`resolve my_expr),1,2,3])
true;

# source: (assert (def my_code
#             (x y z)
#             (x y z)))
#   eval: (`assert (`def my_code
#             (x y z)
#             [ (`resolve x), (`resolve y),
#               (`resolve z)]))
true;

# source: (assert 3
#           (my_code 1 2 3))
#   eval: (`assert 3
#           [ (`resolve my_code),1,2,3])
true;

# source: (assert (del my_code))
#   eval: (`assert (`del my_code))
true;

# ======================================================================
# - List manipulations, assuming that the list is bound to a top-level
# symbol.  NOTE: Jenarix list indices are zero-based (like C/Python)
#   - from front: shift, unshift
# source: (assert (del my_expr))
#   eval: (`assert (`del my_expr))
true;

# source: (assert (set x
#             [2, 3]))
#   eval: (`assert (`set x
#             [2, 3]))
true;

# source: (assert (unshift x 4))
#   eval: (`assert (`unshift (`resolve x) 4))
true;

#   - from end: pop, push & append (synonyms), 
# source: (assert [4, 2, 3] x)
#   eval: (`assert [4, 2, 3]
#           (`resolve x))
true;

# source: (assert (append x 6))
#   eval: (`assert (`append x 6))
true;

#   - copying an entry: get
# source: (assert [4, 2, 3, 6] x)
#   eval: (`assert [4, 2, 3, 6]
#           (`resolve x))
true;

#   - replacing an entry: set
# source: (assert 4
#           (get x 0))
#   eval: (`assert 4
#           (`get x 0))
true;

# source: (assert (set x 3 5))
#   eval: (`assert (`set x 3 5))
true;

#   - removing and returning: take
# source: (assert [4, 2, 3, 5] x)
#   eval: (`assert [4, 2, 3, 5]
#           (`resolve x))
true;

#   - deleting an entry without returning: del
# source: (assert 2
#           (take x 1))
#   eval: (`assert 2
#           (`take x 1))
true;

# source: (assert (del x 0))
#   eval: (`assert (`del x 0))
true;

#   - getting the size of a list
# source: (assert [3, 5] x)
#   eval: (`assert [3, 5]
#           (`resolve x))
true;

# source: (assert 2
#           (size x))
#   eval: (`assert 2
#           (`size (`resolve x)))
true;

#
# Jason's JXON Test Book
#
#############################################################################
#
# 1.0  Simple types: boolean & existance
#
##############################################################################
# source: true
#   eval: true
true;

# source: (not false)
#   eval: (`not false)
true;

# source: (eq true true)
#   eval: (`eq true true)
true;

# source: (eq null null)
#   eval: (`eq null null)
true;

# source: (eq false false)
#   eval: (`eq false false)
true;

# source: (not (eq false true))
#   eval: (`not (`eq false true))
true;

# source: (not (eq false null))
#   eval: (`not (`eq false null))
true;

# source: (not (eq true null))
#   eval: (`not (`eq true null))
true;

# source: (not (eq null ""))
#   eval: (`not (`eq null ""))
true;

# source: (not (eq true ""))
#   eval: (`not (`eq true ""))
true;

# source: (not (eq false ""))
#   eval: (`not (`eq false ""))
true;

# source: (not (eq null
#             []))
#   eval: (`not (`eq null
#             []))
true;

# source: (not (eq true
#             []))
#   eval: (`not (`eq true
#             []))
true;

# source: (not (eq false
#             []))
#   eval: (`not (`eq false
#             []))
true;

# source: (not (eq null -1))
#   eval: (`not (`eq null -1))
true;

# source: (not (eq null 0))
#   eval: (`not (`eq null 0))
true;

# source: (not (eq null 1))
#   eval: (`not (`eq null 1))
true;

# source: (not (eq null 100000.0))
#   eval: (`not (`eq null 100000.0))
true;

##############################################################################
#
# 1.1 -- Simple Numeric Types
#
##############################################################################
# 1.1.1 Numerical In/equality
# source: (eq 1 1)
#   eval: (`eq 1 1)
true;

# source: (not (eq 1 2))
#   eval: (`not (`eq 1 2))
true;

# source: (not (eq -1 1))
#   eval: (`not (`eq -1 1))
true;

# source: (eq 1.1 1.1)
#   eval: (`eq 1.1 1.1)
true;

# source: (not (eq 1.1 1.0))
#   eval: (`not (`eq 1.1 1.0))
true;

# source: (not (eq 1.1 1))
#   eval: (`not (`eq 1.1 1))
true;

# 1.1.2 -- Numerical ordering
# 1.1.2.1 -- less than or equal: le
# source: (le 1 2)
#   eval: (`le 1 2)
true;

# source: (le 1.1 1.2)
#   eval: (`le 1.1 1.2)
true;

# source: (le -1 10)
#   eval: (`le -1 10)
true;

# 1.1.2.2 -- gt
# source: (gt 2 1)
#   eval: (`gt 2 1)
true;

# source: (gt 2.2 1.1)
#   eval: (`gt 2.2 1.1)
true;

# source: (gt 10000.0 1000.0)
#   eval: (`gt 10000.0 1000.0)
true;

# 1.1.2.3 -- lt
# source: (lt 1 2)
#   eval: (`lt 1 2)
true;

# source: (lt 10000.0 100000.0)
#   eval: (`lt 10000.0 100000.0)
true;

# source: (lt -1 1)
#   eval: (`lt -1 1)
true;

# source: (lt -1 0)
#   eval: (`lt -1 0)
true;

# 1.1.2.4 -- ge
# source: (ge 3 1)
#   eval: (`ge 3 1)
true;

# source: (ge 3 -1)
#   eval: (`ge 3 -1)
true;

# source: (ge 1.3 1.2)
#   eval: (`ge 1.3 1.2)
true;

# source: (ge 10000.0 100.0)
#   eval: (`ge 10000.0 100.0)
true;

# 1.1.3 -- operations on numbers
# 1.1.3.1 -- addition
# source: (eq (add 1 1) 2)
#   eval: (`eq (`add 1 1) 2)
true;

# source: (eq (add -1 1) 0)
#   eval: (`eq (`add -1 1) 0)
true;

# source: (eq (add 1.0 1.0) 2.0)
#   eval: (`eq (`add 1.0 1.0) 2.0)
true;

# source: (eq (add 1.0 1.0) 2)
#   eval: (`eq (`add 1.0 1.0) 2)
true;

# source: (eq (add 1000.0 1000.0) 2000.0)
#   eval: (`eq (`add 1000.0 1000.0) 2000.0)
true;

# source: (eq (add 100 -200) -100)
#   eval: (`eq (`add 100 -200) -100)
true;

# 1.1.3.2 -- subtraction
# source: (eq (sub 1 1) 0)
#   eval: (`eq (`sub 1 1) 0)
true;

# source: (eq (sub 1 1) 0.0)
#   eval: (`eq (`sub 1 1) 0.0)
true;

# source: (eq (sub 200 100) 100)
#   eval: (`eq (`sub 200 100) 100)
true;

# source: (eq (sub -100 -200) 100)
#   eval: (`eq (`sub -100 -200) 100)
true;

# source: (eq (sub 100 -200) 300)
#   eval: (`eq (`sub 100 -200) 300)
true;

# source: (eq (sub 400 200) 200)
#   eval: (`eq (`sub 400 200) 200)
true;

# source: (eq (sub 2000.0 1000.0) 1000.0)
#   eval: (`eq (`sub 2000.0 1000.0) 1000.0)
true;

# 1.1.3.3 -- mult
# source: (eq (mul 2 2) 4)
#   eval: (`eq (`mul 2 2) 4)
true;

# source: (eq (mul -2 2) -4)
#   eval: (`eq (`mul -2 2) -4)
true;

# source: (eq (mul 0.5 0.5) 0.25)
#   eval: (`eq (`mul 0.5 0.5) 0.25)
true;

# source: (eq (mul 1 0) 0)
#   eval: (`eq (`mul 1 0) 0)
true;

# source: (eq (mul 1 0) 0.0)
#   eval: (`eq (`mul 1 0) 0.0)
true;

# source: (eq (mul 1 0) 0)
#   eval: (`eq (`mul 1 0) 0)
true;

# source: (eq (mul 1.0 -4) -4)
#   eval: (`eq (`mul 1.0 -4) -4)
true;

# source: (eq (mul 0 0) 0)
#   eval: (`eq (`mul 0 0) 0)
true;

# source: (eq (mul 100.0 100.0) 10000.0)
#   eval: (`eq (`mul 100.0 100.0) 10000.0)
true;

# 1.1.3.4 -- div
# source: (eq (div 2 1) 2)
#   eval: (`eq (`div 2 1) 2)
true;

# source: (eq (div -100 2) -50)
#   eval: (`eq (`div -100 2) -50)
true;

# source: (eq (div -10 -2) 5)
#   eval: (`eq (`div -10 -2) 5)
true;

# 1.1.3.5 -- mod
# source: (eq (mod 4 2) 0)
#   eval: (`eq (`mod 4 2) 0)
true;

# source: (eq (mod 3 2) 1)
#   eval: (`eq (`mod 3 2) 1)
true;

##############################################################################
#
# 1.2 Simple Strings
#
##############################################################################
# 1.2.1 Single quoted
# source: (eq "A" "A")
#   eval: (`eq "A" "A")
true;

# source: (not (eq "A" "a"))
#   eval: (`not (`eq "A" "a"))
true;

# 1.2.2 Case sensitivity
# source: (not (eq "Foo" "foo"))
#   eval: (`not (`eq "Foo" "foo"))
true;

# true
# source: (eq "FoO" "FoO")
#   eval: (`eq "FoO" "FoO")
true;

##############################################################################
#
# 1.3 Containers
#
##############################################################################
#
# 1.3.1 -- lists
# source: (eq []
#           [])
#   eval: (`eq []
#           [])
true;

# source: (eq []
#           [])
#   eval: (`eq []
#           [])
true;

# source: (not (eq []
#             [1]))
#   eval: (`not (`eq []
#             [1]))
true;

# source: (not (eq [-2]
#             []))
#   eval: (`not (`eq [-2]
#             []))
true;

# source: (eq (range 10)
#           (range 10))
#   eval: (`eq (`range 10)
#           (`range 10))
true;

# 1.3.2 -- nested
# source: (eq [ [], []]
#           [ [], []])
#   eval: (`eq [ [], []]
#           [ [], []])
true;

# source: (eq [ [], []]
#           [ [], []])
#   eval: (`eq [ [], []]
#           [ [], []])
true;

# source: (eq [ [], []]
#           [ [], []])
#   eval: (`eq [ [], []]
#           [ [], []])
true;

# source: (not (eq [ [1], []]
#             [ [], [1]]))
#   eval: (`not (`eq [ [1], []]
#             [ [], [1]]))
true;

# end Jason's stuff
# primitives and dictionarys are passed through unmodified
# source: (assert 0 0)
#   eval: (`assert 0 0)
true;

# source: (assert -1 -1)
#   eval: (`assert -1 -1)
true;

# source: (assert 1 1)
#   eval: (`assert 1 1)
true;

# source: (assert 0.0 0.0)
#   eval: (`assert 0.0 0.0)
true;

# source: (assert 1.0 1.0)
#   eval: (`assert 1.0 1.0)
true;

# source: (assert -1.0 -1.0)
#   eval: (`assert -1.0 -1.0)
true;

# source: (assert "hi world" "hi world")
#   eval: (`assert "hi world" "hi world")
true;

# source: (assert identify identify)
#   eval: (`assert (`resolve identify)
#           (`resolve identify))
true;

# source: (assert {} {})
#   eval: (`assert {} {})
true;

# source: (assert {1:2} {1:2})
#   eval: (`assert {1:2} {1:2})
true;

# source: (assert {1:2,3:4} {1:2,3:4})
#   eval: (`assert {1:2,3:4} {1:2,3:4})
true;

# top-level lists are iterated -- only the last element is returned
# source: (assert {1: [2, 3]} {1: [2, 3]})
#   eval: (`assert {1: [2, 3]} {1: [2, 3]})
true;

# source: (assert []
#           [])
#   eval: (`assert []
#           [])
true;

# source: (assert [ []]
#           [ []])
#   eval: (`assert [ []]
#           [ []])
true;

# lists with identifiers which resolve to code are executed
# source: (assert [ [1, 2]]
#           [ [1, 2]])
#   eval: (`assert [ [1, 2]]
#           [ [1, 2]])
true;

# source: (assert (set x 1))
#   eval: (`assert (`set x 1))
true;

# source: (assert 1
#           (get x))
#   eval: (`assert 1
#           (`get x))
true;

# source: (assert (set x 2))
#   eval: (`assert (`set x 2))
true;

# source: (assert 2
#           (get x))
#   eval: (`assert 2
#           (`get x))
true;

# type promotion is in
# source: (assert 3
#           (add 1 2))
#   eval: (`assert 3
#           (`add 1 2))
true;

# source: (assert 3.0
#           (add 1 2.0))
#   eval: (`assert 3.0
#           (`add 1 2.0))
true;

# source: (assert 2
#           (add true true))
#   eval: (`assert 2
#           (`add true true))
true;

# source: (assert 0
#           (sub true true))
#   eval: (`assert 0
#           (`sub true true))
true;

# we have looping constructs
# source: (assert 1
#           (sub true false))
#   eval: (`assert 1
#           (`sub true false))
true;

# source: (assert (set a 10))
#   eval: (`assert (`set a 10))
true;

# source: (assert (set b
#             []))
#   eval: (`assert (`set b
#             []))
true;

# source: (assert (set c {}))
#   eval: (`assert (`set c {}))
true;

# while loop
# source: (assert 0
#           (size (get b)))
#   eval: (`assert 0
#           (`size (`get b)))
true;

# source: (assert (while (get a)
#             [ (append b
#                 (get a)), (set c
#                 (get a) 1),
#               (set a
#                 (sub (get a) 1))]))
#   eval: (`assert (`while (`get a)
#             [ (`append b
#                 (`get a)), (`set c
#                 (`get a) 1),
#               (`set a
#                 (`sub (`get a) 1))]))
true;

# source: (assert [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
#           (get b))
#   eval: (`assert [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
#           (`get b))
true;

# hash comparison (order-independent of course)
# source: (assert (output c))
#   eval: (`assert (`output (`resolve c)))
{2:1,10:1,4:1,8:1,3:1,9:1,6:1,1:1,7:1,5:1};
true;

# source: (assert {2:1,4:1,10:1,8:1,3:1,1:1,6:1,9:1,5:1,7:1}
#           (get c))
#   eval: (`assert {2:1,4:1,10:1,8:1,3:1,1:1,6:1,9:1,5:1,7:1}
#           (`get c))
true;

# source: (assert 10
#           (size (get b)))
#   eval: (`assert 10
#           (`size (`get b)))
true;

# source: (assert 10
#           (size (get c)))
#   eval: (`assert 10
#           (`size (`get c)))
true;

# source: (assert (set b
#             []))
#   eval: (`assert (`set b
#             []))
true;

# source: (assert (for (set a 1)
#             (lt (get a) 10)
#             (set a
#               (add (get a) 1))
#             [ (output a), (append b
#                 (get a))]))
#   eval: (`assert (`for (`set a 1)
#             (`lt (`get a) 10)
#             (`set a
#               (`add (`get a) 1))
#             [ (`output (`resolve a)), (`append b
#                 (`get a))]))
1;
2;
3;
4;
5;
6;
7;
8;
9;
true;

# do loops
# source: (assert [1, 2, 3, 4, 5, 6, 7, 8, 9]
#           (get b))
#   eval: (`assert [1, 2, 3, 4, 5, 6, 7, 8, 9]
#           (`get b))
true;

# source: (assert (set a 1))
#   eval: (`assert (`set a 1))
true;

# source: (assert (do (set a
#               (add 1
#                 (get a)))
#             (lt (get a) 10)))
#   eval: (`assert (`do (`set a
#               (`add 1
#                 (`get a)))
#             (`lt (`get a) 10)))
true;

# source: (assert 10
#           (get a))
#   eval: (`assert 10
#           (`get a))
true;

# source: (assert (set a 1))
#   eval: (`assert (`set a 1))
true;

# source: (assert [ [ [ [null]]]]
#           [ [ [ [ (do (set a
#                       (add 1
#                         (get a)))
#                     (lt (get a) 10))]]]])
#   eval: (`assert [ [ [ [null]]]]
#           [ [ [ [ (`do (`set a
#                       (`add 1
#                         (`get a)))
#                     (`lt (`get a) 10))]]]])
true;

# source: (assert 10
#           (get a))
#   eval: (`assert 10
#           (`get a))
true;

# source: (assert (del a))
#   eval: (`assert (`del a))
true;

# source: (assert -17
#           (del a))
#   eval: (`assert -17
#           (`del a))
true;

# source: (assert (del b))
#   eval: (`assert (`del b))
true;

# source: (assert (del c))
#   eval: (`assert (`del c))
true;

# source: (assert (del x))
#   eval: (`assert (`del x))
true;

# here's where we convince ourselves that weak (borrowed) references
# [used through as L-values] cannot leak or escape from where they're used.
# first, create a heap object
# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# now see what happens when we try to get a borrowed reference
# source: (assert (set x
#             ["-  -  -  -  -  -  -  -"]))
#   eval: (`assert (`set x
#             ["-  -  -  -  -  -  -  -"]))
true;

# source: (assert ["-  -  -  -  -  -  -  -"] x)
#   eval: (`assert ["-  -  -  -  -  -  -  -"]
#           (`resolve x))
true;

# source: (assert [ ["-  -  -  -  -  -  -  -"]]
#           (x))
#   eval: (`assert [ ["-  -  -  -  -  -  -  -"]]
#           [ (`resolve x)])
true;

# source: (assert [ ["-  -  -  -  -  -  -  -"], ["-  -  -  -  -  -  -  -"]]
#           (x x))
#   eval: (`assert [ ["-  -  -  -  -  -  -  -"], ["-  -  -  -  -  -  -  -"]]
#           [ (`resolve x), (`resolve x)])
true;

# source: (assert [ ["-  -  -  -  -  -  -  -"], [ ["-  -  -  -  -  -  -  -"]]]
#           (x (x)))
#   eval: (`assert [ ["-  -  -  -  -  -  -  -"], [ ["-  -  -  -  -  -  -  -"]]]
#           [ (`resolve x), [ (`resolve x)]])
true;

# source: (assert [ ["-  -  -  -  -  -  -  -"], [ ["-  -  -  -  -  -  -  -"]],
#             [ [ ["-  -  -  -  -  -  -  -"]]]]
#           (x (x)
#             [ (x)]))
#   eval: (`assert [ ["-  -  -  -  -  -  -  -"], [ ["-  -  -  -  -  -  -  -"]],
#             [ [ ["-  -  -  -  -  -  -  -"]]]]
#           [ (`resolve x), [ (`resolve x)],
#             [ [ (`resolve x)]]])
true;

# source: (assert ["-  -  -  -  -  -  -  -"] x)
#   eval: (`assert ["-  -  -  -  -  -  -  -"]
#           (`resolve x))
true;

# source: (assert (append x 1))
#   eval: (`assert (`append x 1))
true;

# source: (assert ["-  -  -  -  -  -  -  -",1] x)
#   eval: (`assert ["-  -  -  -  -  -  -  -",1]
#           (`resolve x))
true;

# source: (assert (append x x))
#   eval: (`assert (`append x
#             (`resolve x)))
true;

# source: (assert ["-  -  -  -  -  -  -  -",1,
#             ["-  -  -  -  -  -  -  -",1]]
#           (get x))
#   eval: (`assert ["-  -  -  -  -  -  -  -",1,
#             ["-  -  -  -  -  -  -  -",1]]
#           (`get x))
true;

# source: (assert (append x
#             (get x)))
#   eval: (`assert (`append x
#             (`get x)))
true;

# source: (assert ["-  -  -  -  -  -  -  -",1,
#             ["-  -  -  -  -  -  -  -",1],
#             ["-  -  -  -  -  -  -  -",1,
#               ["-  -  -  -  -  -  -  -",1]]]
#           (get x))
#   eval: (`assert ["-  -  -  -  -  -  -  -",1,
#             ["-  -  -  -  -  -  -  -",1],
#             ["-  -  -  -  -  -  -  -",1,
#               ["-  -  -  -  -  -  -  -",1]]]
#           (`get x))
true;

# source: (assert (set y x))
#   eval: (`assert (`set y
#             (`resolve x)))
true;

# source: (assert ["-  -  -  -  -  -  -  -",1,
#             ["-  -  -  -  -  -  -  -",1],
#             ["-  -  -  -  -  -  -  -",1,
#               ["-  -  -  -  -  -  -  -",1]]]
#           (get y))
#   eval: (`assert ["-  -  -  -  -  -  -  -",1,
#             ["-  -  -  -  -  -  -  -",1],
#             ["-  -  -  -  -  -  -  -",1,
#               ["-  -  -  -  -  -  -  -",1]]]
#           (`get y))
true;

# source: (assert (del x))
#   eval: (`assert (`del x))
true;

# functions with single ident args use their own private namespace 
# but receive the entire payload in one symbol
# functions with [ident ...] args have only positional arguments
# functions with [[ident ...],{ident:default,...}] have both a keyword
# -based default (namespace) and take optional positional args.
# scopeless function behavior (arguments go into _)
# source: (assert ["-  -  -  -  -  -  -  -",1,
#             ["-  -  -  -  -  -  -  -",1],
#             ["-  -  -  -  -  -  -  -",1,
#               ["-  -  -  -  -  -  -  -",1]]]
#           (get y))
#   eval: (`assert ["-  -  -  -  -  -  -  -",1,
#             ["-  -  -  -  -  -  -  -",1],
#             ["-  -  -  -  -  -  -  -",1,
#               ["-  -  -  -  -  -  -  -",1]]]
#           (`get y))
true;

# source: (assert (set a
#             [1, 2, 3, 4]))
#   eval: (`assert (`set a
#             [1, 2, 3, 4]))
true;

# source: (assert (def fn null
#             [ (output _), (get (_ 0) 1)]))
#   eval: (`assert (`def fn null
#             [ (`output (`resolve _)), (`get (_ 0) 1)]))
true;

# container emptyness testing
# source: (assert 2
#           (fn a))
#   eval: (`assert 2
#           [ (`resolve fn), (`resolve a)])
[[1,2,3,4]];
true;

# source: (assert true
#           (test [1,2, {3:4}] true false))
#   eval: (`assert true
#           (`test [1,2, {3:4}] true false))
true;

# source: (assert false
#           (test [] true false))
#   eval: (`assert false
#           (`test [] true false))
true;

# source: (assert true
#           (test {1:2} true false))
#   eval: (`assert true
#           (`test {1:2} true false))
true;

# not this that type of construct does not work because get expects an
# indentifier (simple or compound)
# source: (assert false
#           (test {} true false))
#   eval: (`assert false
#           (`test {} true false))
true;

# source: (assert (get [1, 2, 3] 1))
#   eval: (`assert (`get [1, 2, 3] 1))
true;

# source: (assert (unresolved symbols)
#           (unresolved symbols))
#   eval: (`assert [ (`resolve unresolved), (`resolve symbols)]
#           [ (`resolve unresolved), (`resolve symbols)])
true;

# source: (assert (set a
#             [1.0]))
#   eval: (`assert (`set a
#             [1.0]))
true;

# source: (assert (resize a 100 0.5))
#   eval: (`assert (`resize (`resolve a) 100 0.5))
true;

# source: (assert [1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5] a)
#   eval: (`assert [1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
#           (`resolve a))
true;

# source: (assert 100
#           (size a))
#   eval: (`assert 100
#           (`size (`resolve a)))
true;

# source: (assert (resize a 10))
#   eval: (`assert (`resize (`resolve a) 10))
true;

# source: (assert [1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
#           (get a))
#   eval: (`assert [1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]
#           (`get a))
true;

# source: (assert 10
#           (size a))
#   eval: (`assert 10
#           (`size (`resolve a)))
true;

# source: (assert (set fn
#             (lambda null
#               (add (get (_ 0) 1) 2))))
#   eval: (`assert (`set fn
#             (`lambda null
#               (`add (`get (_ 0) 1) 2))))
true;

# scopeless functions inherit their environment (dynamic scoping)
# source: (assert 2.5
#           (fn a))
#   eval: (`assert 2.5
#           [ (`resolve fn), (`resolve a)])
true;

# source: (assert (def test1 null
#             (get x)))
#   eval: (`assert (`def test1 null
#             (`get x)))
true;

# source: (assert (set x 3))
#   eval: (`assert (`set x 3))
true;

# scopefull function with no parameter list
# source: (assert 3
#           (test1))
#   eval: (`assert 3
#           [ (`resolve test1)])
true;

# source: (assert (def test1 {x:2}
#             (get x)))
#   eval: (`assert (`def test1 {x:2}
#             (`get x)))
true;

# source: (assert 2
#           (test1))
#   eval: (`assert 2
#           [ (`resolve test1)])
true;

# source: (assert 8
#           (apply (lambda null 8)))
#   eval: (`assert 8
#           (`apply (`lambda null 8)))
true;

# notice how lambda returns the whole expr, unlike def which iterates
# the expr
# source: (assert (set a 3))
#   eval: (`assert (`set a 3))
true;

# source: (assert [null,9]
#           (apply (lambda null
#               [ (set a 9), (get a)])))
#   eval: (`assert [null,9]
#           (`apply (`lambda null
#               [ (`set a 9), (`get a)])))
true;

# source: (assert (del a))
#   eval: (`assert (`del a))
true;

# source: (assert (del x))
#   eval: (`assert (`del x))
true;

# source: (assert (del y))
#   eval: (`assert (`del y))
true;

# source: (assert (del fn))
#   eval: (`assert (`del fn))
true;

# source: (assert (del test1))
#   eval: (`assert (`del test1))
true;

# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# source: (assert (def vector_add
#             (v0 v1)
#             [ (if (ne (size v0)
#                   (size v1))
#                 [ (output "Vector size mismatch")]
#                 [ (set r
#                     []), (while v0
#                     (append r
#                       (add (shift v0)
#                         (shift v1)))),r])]))
#   eval: (`assert (`def vector_add
#             (v0 v1)
#             [ (`if (`ne (`size (`resolve v0))
#                   (`size (`resolve v1)))
#                 [ (`output "Vector size mismatch")]
#                 [ (`set r
#                     []), (`while (`resolve v0)
#                     (`append r
#                       (`add (`shift (`resolve v0))
#                         (`shift (`resolve v1))))),
#                   (`resolve r)])]))
true;

# source: (assert [3, 5, 7]
#           (vector_add [1, 2, 3]
#             [2, 3, 4]))
#   eval: (`assert [3, 5, 7]
#           [ (`resolve vector_add), [1, 2, 3],
#             [2, 3, 4]])
true;

# source: (assert 1000
#           (size (vector_add (range 1000)
#               (range 1000))))
#   eval: (`assert 1000
#           (`size [ (`resolve vector_add), (`range 1000),
#               (`range 1000)]))
true;

# source: (assert (def vector_add
#             (v0 v1)
#             [ (if (ne (size v0)
#                   (size v1))
#                 [ (output "Vector size mismatch")]
#                 [ (map (lambda (x y)
#                       (add x y)) v0 v1)])]))
#   eval: (`assert (`def vector_add
#             (v0 v1)
#             [ (`if (`ne (`size (`resolve v0))
#                   (`size (`resolve v1)))
#                 [ (`output "Vector size mismatch")]
#                 [ (`map (`lambda (x y)
#                       (`add (`resolve x)
#                         (`resolve y)))
#                     (`resolve v0)
#                     (`resolve v1))])]))
true;

# source: (assert [3, 5, 7]
#           (vector_add [1, 2, 3]
#             [2, 3, 4]))
#   eval: (`assert [3, 5, 7]
#           [ (`resolve vector_add), [1, 2, 3],
#             [2, 3, 4]])
true;

# source: (assert 2000
#           (size (vector_add (range 2000)
#               (range 2000))))
#   eval: (`assert 2000
#           (`size [ (`resolve vector_add), (`range 2000),
#               (`range 2000)]))
true;

# TAIL RECURSION
# with tail recursion, result is 20
# source: (assert (del vector_add))
#   eval: (`assert (`del vector_add))
true;

# source: (assert (def tail_test
#             (x)
#             [ (output x), (test (lt x 20)
#                 (tail (add x 1)) x),x]))
#   eval: (`assert (`def tail_test
#             (x)
#             [ (`output (`resolve x)), (`test (`lt (`resolve x) 20)
#                 (`tail (`add (`resolve x) 1))
#                 (`resolve x)),
#               (`resolve x)]))
true;

# without tail recursion, result is 10
# source: (assert 20
#           (tail_test 10))
#   eval: (`assert 20
#           [ (`resolve tail_test),10])
10;
11;
12;
13;
14;
15;
16;
17;
18;
19;
20;
true;

# source: (assert (def tail_test
#             (x)
#             [ (output x), (test (lt x 20)
#                 (tail_test (add x 1)) x),x]))
#   eval: (`assert (`def tail_test
#             (x)
#             [ (`output (`resolve x)), (`test (`lt (`resolve x) 20)
#                 [ (`resolve tail_test), (`add (`resolve x) 1)]
#                 (`resolve x)),
#               (`resolve x)]))
true;

# source: (assert 10
#           (tail_test 10))
#   eval: (`assert 10
#           [ (`resolve tail_test),10])
10;
11;
12;
13;
14;
15;
16;
17;
18;
19;
20;
true;

# source: (assert (del tail_test))
#   eval: (`assert (`del tail_test))
true;

# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# SPECIAL FORMS
# 'quote' returns the first argument after prebinding but before evaluation
# 'eval' is the antidote to quote
# source: (assert (quote (add 1 2))
#           (quote (add 1 2)))
#   eval: (`assert (`quote (`add 1 2))
#           (`quote (`add 1 2)))
true;

# 'raw' returns the first argument without performing any prebinding or evaluation
# what you get from raw is essentially source code
# source: (assert 3
#           (eval (quote (add 1 2))))
#   eval: (`assert 3
#           (`eval (`quote (`add 1 2))))
true;

# 'bind' converts the output of raw into prebound code
# source: (assert (raw (add 1 2))
#           (raw (add 1 2)))
#   eval: (`assert (`raw (add 1 2))
#           (`raw (add 1 2)))
true;

# source: (assert (quote (add 1 2))
#           (bind (raw (add 1 2))))
#   eval: (`assert (`quote (`add 1 2))
#           (`bind (`raw (add 1 2))))
true;

# when combined with eval, you get the full JXON evaluation pipeline
# result: 3
# the special form 'pass' simply passes the value through (can be used
# to evaluate forms which return functions without calling the
# functions and without using get)
# source: (assert 3
#           (eval (bind (raw (add 1 2)))))
#   eval: (`assert 3
#           (`eval (`bind (`raw (add 1 2)))))
true;

# source: (assert (set fn
#             (lambda (x) 1)))
#   eval: (`assert (`set fn
#             (`lambda (x) 1)))
true;

# source: (assert 1
#           (fn))
#   eval: (`assert 1
#           [ (`resolve fn)])
true;

# source: (assert (output (pass fn)))
#   eval: (`assert (`output (`pass (`resolve fn))))
fn`0xXXXXXX;
true;

# output: fn`0xXXXXXX
# 'nop' gets excised when binding is performed... upon binding, the
# first argument to nop replaces it
# result: [ (`resolve a), (`resolve b),
#           (`resolve c)]
# source: (assert (quote (a b c))
#           (quote (nop (a b c))))
#   eval: (`assert (`quote [ (`resolve a), (`resolve b),
#               (`resolve c)])
#           (`quote [ (`resolve a), (`resolve b),
#               (`resolve c)]))
true;

# source: (assert (del fn))
#   eval: (`assert (`del fn))
true;

# closure01
# Jenarix functions statically close on free variables using the
# surrounding scope
# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# source: (assert (set x
#             [1, 2, 3]))
#   eval: (`assert (`set x
#             [1, 2, 3]))
true;

# source: (assert (set z
#             [3, 4, 5]))
#   eval: (`assert (`set z
#             [3, 4, 5]))
true;

# source: (assert (def myfn
#             [ (x y), {y: [2, 3, 4]}]
#             [ (x y z)]))
#   eval: (`assert (`def myfn
#             [ (x y), {y: [2, 3, 4]}]
#             [ [ (`resolve x), (`resolve y),
#                 (`resolve z)]]))
true;

# source: (assert (output (impl myfn)))
#   eval: (`assert (`output (`impl (`resolve myfn))))
[myfn,[[x,y],{x:[1,2,3],z:[3,4,5],y:[2,3,4]}],[[[`resolve,x],[`resolve,y],[`resolve,z]]],true];
true;

# source: (assert [ [1, 2, 3], [2, 3, 4],
#             [3, 4, 5]]
#           (myfn))
#   eval: (`assert [ [1, 2, 3], [2, 3, 4],
#             [3, 4, 5]]
#           [ (`resolve myfn)])
true;

# source: (assert [1, [2, 3, 4],
#             [3, 4, 5]]
#           (myfn 1))
#   eval: (`assert [1, [2, 3, 4],
#             [3, 4, 5]]
#           [ (`resolve myfn),1])
true;

# source: (assert [1,2,
#             [3, 4, 5]]
#           (myfn 1 2))
#   eval: (`assert [1,2,
#             [3, 4, 5]]
#           [ (`resolve myfn),1,2])
true;

# source: (assert (del x))
#   eval: (`assert (`del x))
true;

# source: (assert (del z))
#   eval: (`assert (`del z))
true;

# source: (assert (del myfn))
#   eval: (`assert (`del myfn))
true;

# closure02
# another illustration of how Jenarix closures work
# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# source: (assert (def fnbuilder
#             (y)
#             (lambda [] y)))
#   eval: (`assert (`def fnbuilder
#             (y)
#             (`lambda []
#               (`resolve y))))
true;

# source: (assert (set newfn
#             (fnbuilder 2)))
#   eval: (`assert (`set newfn
#             [ (`resolve fnbuilder),2]))
true;

# source: (assert (output (symbols false)))
#   eval: (`assert (`output (`symbols false)))
{newfn:fn`0xXXXXXX,fnbuilder:fn`fnbuilder};
true;

# source: (assert 2
#           (newfn))
#   eval: (`assert 2
#           [ (`resolve newfn)])
true;

# source: (assert (set v
#             [1, 2]))
#   eval: (`assert (`set v
#             [1, 2]))
true;

# source: (assert (set newfn
#             (fnbuilder v)))
#   eval: (`assert (`set newfn
#             [ (`resolve fnbuilder), (`resolve v)]))
true;

# note that value of v was closed on (copied) at the time of function
# creation.  Changing v later has no effect on the function.
# source: (assert [1, 2]
#           (newfn))
#   eval: (`assert [1, 2]
#           [ (`resolve newfn)])
true;

# source: (assert (append v 3))
#   eval: (`assert (`append v 3))
true;

# source: (assert [1, 2, 3] v)
#   eval: (`assert [1, 2, 3]
#           (`resolve v))
true;

# source: (assert [1, 2]
#           (newfn))
#   eval: (`assert [1, 2]
#           [ (`resolve newfn)])
true;

# source: (assert (output (symbols false)))
#   eval: (`assert (`output (`symbols false)))
{v:[1,2,3],fnbuilder:fn`fnbuilder,newfn:fn`0xXXXXXX};
true;

# source: (assert (del v))
#   eval: (`assert (`del v))
true;

# source: (assert (del fnbuilder))
#   eval: (`assert (`del fnbuilder))
true;

# source: (assert (del newfn))
#   eval: (`assert (`del newfn))
true;

# source: (assert (output (symbols false)))
#   eval: (`assert (`output (`symbols false)))
{};
true;

# closure03
# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# source: (assert (def vector.add
#             (v1 v2)
#             [ [ (v1 0), (map (lambda (x y)
#                     (add x y))
#                   (v1 1)
#                   (v2 1))]]))
#   eval: (`assert (`def vector.add
#             (v1 v2)
#             [ [ [ (`resolve v1),0], (`map (`lambda (x y)
#                     (`add (`resolve x)
#                       (`resolve y)))
#                   [ (`resolve v1),1]
#                   [ (`resolve v2),1])]]))
true;

# source: (assert (output (impl vector.add)))
#   eval: (`assert (`output (`impl (`resolve (vector add)))))
[vector.add,[[v1,v2],{}],[[[[`resolve,v1],0],[`map,[`lambda,[x,y],[`add,[`resolve,x],[`resolve,y]]],[[`resolve,v1],1],[[`resolve,v2],1]]]],true];
true;

# source: (assert (output (symbols false)))
#   eval: (`assert (`output (`symbols false)))
{vector:{add:fn`vector.add}};
true;

# source: (assert (entity VectorBase null null {add:vector.add}) VectorBase)
#   eval: (`assert (`entity VectorBase null null {add: (`resolve (vector add))})
#           (`resolve VectorBase))
true;

# referring to Vector inside the function is sufficient to create the
# closure
# source: (assert (entity Vector VectorBase null null) Vector)
#   eval: (`assert (`entity Vector
#             (`resolve VectorBase) null null)
#           (`resolve Vector))
true;

# notice how the Vector definition is in the function's implementation
# source: (assert (def myfn
#             (a b)
#             [ (Vector), (a add b)]))
#   eval: (`assert (`def myfn
#             (a b)
#             [ [ (`resolve Vector)], [ (`resolve a), (`resolve add),
#                 (`resolve b)]]))
true;

# if we create some vector instances
# source: (assert (output (impl myfn)))
#   eval: (`assert (`output (`impl (`resolve myfn))))
[myfn,[[a,b],{Vector:.Vector,.Vector:[.VectorBase,null,null],.VectorBase:[null,null,{add:fn`vector.add}]}],[[[`resolve,Vector]],[[`resolve,a],[`resolve,add],[`resolve,b]]],true];
true;

# source: (assert (set v1
#             (Vector [1, 2, 3])))
#   eval: (`assert (`set v1
#             [ (`resolve Vector), [1, 2, 3]]))
true;

# both the function and the local entity methods work on them
# source: (assert (set v2
#             (Vector [2, 3, 4])))
#   eval: (`assert (`set v2
#             [ (`resolve Vector), [2, 3, 4]]))
true;

# source: (assert (Vector [3, 5, 7])
#           (myfn v1 v2))
#   eval: (`assert [ (`resolve Vector), [3, 5, 7]]
#           [ (`resolve myfn), (`resolve v1),
#             (`resolve v2)])
true;

# strictly speaking however, we can instead rely upon dynamic
# referencing of the class at the point of method invocation
# source: (assert (Vector [3, 5, 7])
#           (v1 add v2))
#   eval: (`assert [ (`resolve Vector), [3, 5, 7]]
#           [ (`resolve v1), (`resolve add),
#             (`resolve v2)])
true;

# source: (assert (def myfn2
#             (a b)
#             [ (a add b)]))
#   eval: (`assert (`def myfn2
#             (a b)
#             [ [ (`resolve a), (`resolve add),
#                 (`resolve b)]]))
true;

# source: (assert (output (impl myfn2)))
#   eval: (`assert (`output (`impl (`resolve myfn2))))
[myfn2,[[a,b],{}],[[[`resolve,a],[`resolve,add],[`resolve,b]]],true];
true;

# but that only works if the class is present and bound in the caller's namespace
# if we've nuked it 
# source: (assert (Vector [3, 5, 7])
#           (myfn2 v1 v2))
#   eval: (`assert [ (`resolve Vector), [3, 5, 7]]
#           [ (`resolve myfn2), (`resolve v1),
#             (`resolve v2)])
true;

# source: (assert (del [ (pass Vector)]))
#   eval: (`assert (`del [ (`pass (`resolve Vector))]))
true;

# source: (assert (del Vector))
#   eval: (`assert (`del Vector))
true;

# then that doesn't work
# source: (assert (output (symbols false)))
#   eval: (`assert (`output (`symbols false)))
{myfn:fn`myfn,VectorBase:.VectorBase,vector:{add:fn`vector.add},.VectorBase:[null,null,{add:fn`vector.add}],v2:[.Vector,[2,3,4]],v1:[.Vector,[1,2,3]],myfn2:fn`myfn2};
true;

# whereas the function with closed entity definitions still works
# source: (assert (myfn2 v1 v2))
#   eval: (`assert [ (`resolve myfn2), (`resolve v1),
#             (`resolve v2)])
true;

# source: (assert (output (myfn v1 v2)))
#   eval: (`assert (`output [ (`resolve myfn), (`resolve v1),
#               (`resolve v2)]))
[.Vector,[3,5,7]];
true;

# source: (assert (output (symbols false)))
#   eval: (`assert (`output (`symbols false)))
{myfn:fn`myfn,VectorBase:.VectorBase,vector:{add:fn`vector.add},.VectorBase:[null,null,{add:fn`vector.add}],v2:[.Vector,[2,3,4]],v1:[.Vector,[1,2,3]],myfn2:fn`myfn2};
true;

# source: (assert (del v1))
#   eval: (`assert (`del v1))
true;

# source: (assert (del v2))
#   eval: (`assert (`del v2))
true;

# source: (assert (del vector.add))
#   eval: (`assert (`del (vector add)))
true;

# source: (assert (del vector))
#   eval: (`assert (`del vector))
true;

# source: (assert (del myfn2))
#   eval: (`assert (`del myfn2))
true;

# source: (assert (del myfn))
#   eval: (`assert (`del myfn))
true;

# source: (assert (del [ (pass VectorBase)]))
#   eval: (`assert (`del [ (`pass (`resolve VectorBase))]))
true;

# source: (assert (del VectorBase))
#   eval: (`assert (`del VectorBase))
true;

# source: (assert (output (symbols false)))
#   eval: (`assert (`output (`symbols false)))
{};
true;

# continue
# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# source: (assert (set a 10))
#   eval: (`assert (`set a 10))
true;

# source: (assert 5
#           (while (decr a)
#             [ (output a), (test (gt a 5)
#                 (continue) a),
#               (break)]))
#   eval: (`assert 5
#           (`while (`decr a)
#             [ (`output (`resolve a)), (`test (`gt (`resolve a) 5)
#                 (`continue)
#                 (`resolve a)),
#               (`break)]))
9;
8;
7;
6;
5;
true;

# source: (assert (output (symbols false)))
#   eval: (`assert (`output (`symbols false)))
{a:5};
true;

# source: (assert (del a))
#   eval: (`assert (`del a))
true;

# source: (assert (output (symbols false)))
#   eval: (`assert (`output (`symbols false)))
{};
true;

# entity02
# here's an example vector addition function
# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# source: (assert (def vector_add
#             (v1 v2)
#             [ [ (v1 0), (map (lambda (x y)
#                     (add x y))
#                   (v1 1)
#                   (v2 1))]]))
#   eval: (`assert (`def vector_add
#             (v1 v2)
#             [ [ [ (`resolve v1),0], (`map (`lambda (x y)
#                     (`add (`resolve x)
#                       (`resolve y)))
#                   [ (`resolve v1),1]
#                   [ (`resolve v2),1])]]))
true;

# source: (assert (entity Vector null null {add:vector_add}) Vector)
#   eval: (`assert (`entity Vector null null {add: (`resolve vector_add)})
#           (`resolve Vector))
true;

# source: (assert (del vector_add))
#   eval: (`assert (`del vector_add))
true;

# source: (assert (set v1
#             (Vector [1, 2, 3])))
#   eval: (`assert (`set v1
#             [ (`resolve Vector), [1, 2, 3]]))
true;

# entity-based invocation
# source: (assert (set v2
#             (Vector [2, 3, 4])))
#   eval: (`assert (`set v2
#             [ (`resolve Vector), [2, 3, 4]]))
true;

# dot-based invocation
# source: (assert (Vector [3, 5, 7])
#           (v1 add v2))
#   eval: (`assert [ (`resolve Vector), [3, 5, 7]]
#           [ (`resolve v1), (`resolve add),
#             (`resolve v2)])
true;

# source: (assert (Vector [3, 5, 7])
#           (v1.add v2))
#   eval: (`assert [ (`resolve Vector), [3, 5, 7]]
#           [ (`resolve (v1 add)), (`resolve v2)])
true;

# source: (assert (Vector [0.6,13,"hiyou"])
#           [ (Vector [0.3,4,"hi"]),add,
#             (Vector [0.3,9,"you"])])
#   eval: (`assert [ (`resolve Vector), [0.6,13,"hiyou"]]
#           [ [ (`resolve Vector), [0.3,4,"hi"]], (`resolve add),
#             [ (`resolve Vector), [0.3,9,"you"]]])
true;

# source: (assert (del v1))
#   eval: (`assert (`del v1))
true;

# source: (assert (del v2))
#   eval: (`assert (`del v2))
true;

# source: (assert (del [ (pass Vector)]))
#   eval: (`assert (`del [ (`pass (`resolve Vector))]))
true;

# source: (assert (del Vector))
#   eval: (`assert (`del Vector))
true;

# entity03
# polymorphic functions can be created as follows
# first, we define two entity classes 
# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# source: (assert (entity A) A)
#   eval: (`assert (`entity A)
#           (`resolve A))
true;

# then we create and populate a hash that will act as a dispatch table
# source: (assert (entity B) B)
#   eval: (`assert (`entity B)
#           (`resolve B))
true;

# source: (assert (set poly_disp {}))
#   eval: (`assert (`set poly_disp {}))
true;

# source: (assert (set poly_disp A
#             (lambda (self x)
#               [ ["A called with",x]])))
#   eval: (`assert (`set poly_disp
#             (`resolve A)
#             (`lambda (self x)
#               [ ["A called with", (`resolve x)]])))
true;

# now we define a scopeless function that can use the hash
# source: (assert (set poly_disp B
#             (lambda (self x)
#               [ ["B called with",x]])))
#   eval: (`assert (`set poly_disp
#             (`resolve B)
#             (`lambda (self x)
#               [ ["B called with", (`resolve x)]])))
true;

# source: (assert (def poly_fn null
#             (apply (get poly_disp
#                 [ (get _ 0),0]) _)))
#   eval: (`assert (`def poly_fn null
#             (`apply (`get poly_disp
#                 [ (`get _ 0),0])
#               (`resolve _))))
true;

# source: (assert (output (impl poly_fn)))
#   eval: (`assert (`output (`impl (`resolve poly_fn))))
[poly_fn,null,[`apply,[`get,poly_disp,[[`get,_,0],0]],[`resolve,_]],true];
true;

# finally, to show off, we create one entity of each type
# source: (assert (set a
#             (A)))
#   eval: (`assert (`set a
#             [ (`resolve A)]))
true;

# and use the polymorphic function on those entities :)!
# source: (assert (set b
#             (B)))
#   eval: (`assert (`set b
#             [ (`resolve B)]))
true;

# source: (assert [ ["A called with",1]]
#           (poly_fn a 1))
#   eval: (`assert [ ["A called with",1]]
#           [ (`resolve poly_fn), (`resolve a),1])
true;

# source: (assert [ ["B called with",2]]
#           (poly_fn b 2))
#   eval: (`assert [ ["B called with",2]]
#           [ (`resolve poly_fn), (`resolve b),2])
true;

# source: (assert (del a))
#   eval: (`assert (`del a))
true;

# source: (assert (del b))
#   eval: (`assert (`del b))
true;

# source: (assert (del [ (pass A)]))
#   eval: (`assert (`del [ (`pass (`resolve A))]))
true;

# source: (assert (del [ (pass B)]))
#   eval: (`assert (`del [ (`pass (`resolve B))]))
true;

# source: (assert (del A))
#   eval: (`assert (`del A))
true;

# source: (assert (del B))
#   eval: (`assert (`del B))
true;

# source: (assert (del poly_fn))
#   eval: (`assert (`del poly_fn))
true;

# source: (assert (del poly_disp))
#   eval: (`assert (`del poly_disp))
true;

# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# experimenting with dot notation for calling methods on entity
# source: (assert (entity A null null {class_fn: (lambda (self)
#               ["from class", (get (self 1) 2)])}) A)
#   eval: (`assert (`entity A null null {class_fn: (`lambda (self)
#               ["from class", (`get (self 1) 2)])})
#           (`resolve A))
true;

# the pseudo-LISP way
# source: (assert (set b
#             (A [1, 2, 3] {inst_fn: (lambda (self)
#                 ["from instance", (get (self 1) 2)])})))
#   eval: (`assert (`set b
#             [ (`resolve A), [1, 2, 3], {inst_fn: (`lambda (self)
#                 ["from instance", (`get (self 1) 2)])}]))
true;

# source: (assert ["from instance",3]
#           (b inst_fn))
#   eval: (`assert ["from instance",3]
#           [ (`resolve b), (`resolve inst_fn)])
true;

# the pseudo-Python way
# source: (assert ["from class",3]
#           (b class_fn))
#   eval: (`assert ["from class",3]
#           [ (`resolve b), (`resolve class_fn)])
true;

# source: (assert ["from instance",3]
#           (b.inst_fn))
#   eval: (`assert ["from instance",3]
#           [ (`resolve (b inst_fn))])
true;

# source: (assert ["from class",3]
#           (b.class_fn))
#   eval: (`assert ["from class",3]
#           [ (`resolve (b class_fn))])
true;

# source: (assert (del b))
#   eval: (`assert (`del b))
true;

# source: (assert (del [ (pass A)]))
#   eval: (`assert (`del [ (`pass (`resolve A))]))
true;

# source: (assert (del A))
#   eval: (`assert (`del A))
true;

# verify access to attributes
# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# source: (assert (entity Matrix) Matrix)
#   eval: (`assert (`entity Matrix)
#           (`resolve Matrix))
true;

# conventional attribute resolution
# source: (assert (set mat
#             (Matrix [0, 0, 0, 0, 0, 0, 0, 0, 0] {dim: [3, 3]})))
#   eval: (`assert (`set mat
#             [ (`resolve Matrix), [0, 0, 0, 0, 0, 0, 0, 0, 0], {dim: [3, 3]}]))
true;

# source: (assert [3, 3]
#           (mat dim))
#   eval: (`assert [3, 3]
#           [ (`resolve mat), (`resolve dim)])
true;

# note that we've modified dim
# source: (assert (append (mat dim) 1))
#   eval: (`assert (`append (mat dim) 1))
true;

# source: (assert (output mat))
#   eval: (`assert (`output (`resolve mat)))
[.Matrix,[0,0,0,0,0,0,0,0,0],{dim:[3,3,1]}];
true;

# source: (assert [3, 3, 1]
#           (mat dim))
#   eval: (`assert [3, 3, 1]
#           [ (`resolve mat), (`resolve dim)])
true;

# dot-based attribute resolution
# source: (assert 1
#           (pop mat.dim))
#   eval: (`assert 1
#           (`pop (`resolve (mat dim))))
true;

# note that in both cases, we're returned a weak reference to the
# attributes which can be directly operated upon
# a copy isn't made until we assign
# source: (assert (output mat))
#   eval: (`assert (`output (`resolve mat)))
[.Matrix,[0,0,0,0,0,0,0,0,0],{dim:[3,3]}];
true;

# source: (assert (set dim mat.dim))
#   eval: (`assert (`set dim
#             (`resolve (mat dim))))
true;

# source: (assert (append dim 1))
#   eval: (`assert (`append dim 1))
true;

# source: (assert [3, 3, 1] dim)
#   eval: (`assert [3, 3, 1]
#           (`resolve dim))
true;

# double-check our ability to access entity components
# source: (assert [3, 3] mat.dim)
#   eval: (`assert [3, 3]
#           (`resolve (mat dim)))
true;

# source: (assert Matrix
#           (mat 0))
#   eval: (`assert (`resolve Matrix)
#           [ (`resolve mat),0])
true;

# source: (assert [0, 0, 0, 0, 0, 0, 0, 0, 0]
#           (mat 1))
#   eval: (`assert [0, 0, 0, 0, 0, 0, 0, 0, 0]
#           [ (`resolve mat),1])
true;

# source: (assert {dim: [3, 3]}
#           (mat 2))
#   eval: (`assert {dim: [3, 3]}
#           [ (`resolve mat),2])
true;

# source: (assert (mat 3))
#   eval: (`assert [ (`resolve mat),3])
true;

# source: (assert (del dim))
#   eval: (`assert (`del dim))
true;

# source: (assert (del [ (pass Matrix)]))
#   eval: (`assert (`del [ (`pass (`resolve Matrix))]))
true;

# source: (assert (del Matrix))
#   eval: (`assert (`del Matrix))
true;

# source: (assert (del mat))
#   eval: (`assert (`del mat))
true;

# test construction
# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# source: (assert (def _method
#             (self x)
#             [ (self 1),x]))
#   eval: (`assert (`def _method
#             (self x)
#             [ [ (`resolve self),1], (`resolve x)]))
true;

# source: (assert (entity MatrixBase null null {dim: [],method:_method}) MatrixBase)
#   eval: (`assert (`entity MatrixBase null null {dim: [],method: (`resolve _method)})
#           (`resolve MatrixBase))
true;

# source: (assert (del _method))
#   eval: (`assert (`del _method))
true;

# source: (assert (entity Matrix33f MatrixBase
#             [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0] {dim: [3, 3]}) Matrix33f)
#   eval: (`assert (`entity Matrix33f
#             (`resolve MatrixBase)
#             [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0] {dim: [3, 3]})
#           (`resolve Matrix33f))
true;

# source: (assert (output (symbols false)))
#   eval: (`assert (`output (`symbols false)))
{Matrix33f:.Matrix33f,.Matrix33f:[.MatrixBase,[1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0],{dim:[3,3]}],MatrixBase:.MatrixBase,.MatrixBase:[null,null,{dim:[],method:fn`_method}]};
true;

# new instances can be automatically created by resolving the entity handle and then
# calling it as a function 
# source: (assert (set m1
#             [ (Matrix33f)]))
#   eval: (`assert (`set m1
#             [ [ (`resolve Matrix33f)]]))
true;

# source: (assert (Matrix33f [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0] {dim: [3, 3]}) m1)
#   eval: (`assert [ (`resolve Matrix33f), [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0], {dim: [3, 3]}]
#           (`resolve m1))
true;

# source: (assert (del [ (pass MatrixBase)]))
#   eval: (`assert (`del [ (`pass (`resolve MatrixBase))]))
true;

# source: (assert (del MatrixBase))
#   eval: (`assert (`del MatrixBase))
true;

# source: (assert (del [ (pass Matrix33f)]))
#   eval: (`assert (`del [ (`pass (`resolve Matrix33f))]))
true;

# source: (assert (del Matrix33f))
#   eval: (`assert (`del Matrix33f))
true;

# source: (assert (del m1))
#   eval: (`assert (`del m1))
true;

# delaring an entity effectively reserves the identifier for use by the entity
# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# source: (assert (entity Vector) Vector)
#   eval: (`assert (`entity Vector)
#           (`resolve Vector))
true;

# result: .Vector
# Notice that two entries are created in the symbol table, one which
# binds the entity name (Vector) to the builtin entity handle
# (.Vector) and a second which binds the handle to the attribute table
# (which can be null)
# creating an instance the manual way...
# source: (assert (output (symbols false)))
#   eval: (`assert (`output (`symbols false)))
{Vector:.Vector,.Vector:[null,null,null]};
true;

# source: (assert (set vect1
#             (Vector [1, 0, 0, 0, 1, 0, 0, 0, 1] {take_first_two: (lambda (self)
#                 (cutout (self 1) 0 2))})))
#   eval: (`assert (`set vect1
#             [ (`resolve Vector), [1, 0, 0, 0, 1, 0, 0, 0, 1], {take_first_two: (`lambda (self)
#                 (`cutout [ (`resolve self),1] 0 2))}]))
true;

# Bound methods ends up calling the associated function
# source: (assert (output vect1))
#   eval: (`assert (`output (`resolve vect1)))
[.Vector,[1,0,0,0,1,0,0,0,1],{take_first_two:fn`0xXXXXXX}];
true;

# calling an unbound method currently acts like a nop -- this should
# probably be changed to either return null or throw an error
# source: (assert [1, 0]
#           (vect1 take_first_two))
#   eval: (`assert [1, 0]
#           [ (`resolve vect1), (`resolve take_first_two)])
true;

# entity-wide methods are stored in the entity definition
# source: (assert (vect1 length))
#   eval: (`assert [ (`resolve vect1), (`resolve length)])
true;

# source: (assert (entity Vector null null {length: (lambda (self)
#               (size (self 1)))}) Vector)
#   eval: (`assert (`entity Vector null null {length: (`lambda (self)
#               (`size [ (`resolve self),1]))})
#           (`resolve Vector))
true;

# result: { ..., Vector: {length:fn`0xXXXXXX}, ... }
# newly-defined class methods are available to all instances in the namespace
# source: (assert (output (symbols false)))
#   eval: (`assert (`output (`symbols false)))
{vect1:[.Vector,[0,0,1,0,0,0,1],{take_first_two:fn`0xXXXXXX}],Vector:.Vector,.Vector:[null,null,{length:fn`0xXXXXXX}]};
true;

# result: 7
# source: (assert 7
#           (vect1 length))
#   eval: (`assert 7
#           [ (`resolve vect1), (`resolve length)])
true;

# source: (assert (del [ (pass Vector)]))
#   eval: (`assert (`del [ (`pass (`resolve Vector))]))
true;

# source: (assert (del Vector))
#   eval: (`assert (`del Vector))
true;

# source: (assert (del vect1))
#   eval: (`assert (`del vect1))
true;

# functions returning functions
# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# source: (assert (def addN
#             (x)
#             (lambda (y)
#               (add x y))))
#   eval: (`assert (`def addN
#             (x)
#             (`lambda (y)
#               (`add (`resolve x)
#                 (`resolve y)))))
true;

# source: (assert (set add2
#             (addN 2)))
#   eval: (`assert (`set add2
#             [ (`resolve addN),2]))
true;

# source: (assert 7
#           (add2 5))
#   eval: (`assert 7
#           [ (`resolve add2),5])
true;

# source: (assert (del addN))
#   eval: (`assert (`del addN))
true;

# source: (assert (del add2))
#   eval: (`assert (`del add2))
true;

# build a list
# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

# source: (assert (set a 2000))
#   eval: (`assert (`set a 2000))
true;

# source: (assert (set b
#             []))
#   eval: (`assert (`set b
#             []))
true;

# source: (assert null
#           (while a
#             (append b
#               (decr a))))
#   eval: (`assert null
#           (`while (`resolve a)
#             (`append b
#               (`decr a))))
true;

# source: (assert 2000
#           (get b 0))
#   eval: (`assert 2000
#           (`get b 0))
true;

# build a hash
# build a million-element hash as fast as you can!
# source: (assert 2000
#           (size b))
#   eval: (`assert 2000
#           (`size (`resolve b)))
true;

# source: (assert (set a 1000))
#   eval: (`assert (`set a 1000))
true;

# source: (assert (set b {}))
#   eval: (`assert (`set b {}))
true;

# source: (assert null
#           (while a
#             (set b
#               (decr a) 1)))
#   eval: (`assert null
#           (`while (`resolve a)
#             (`set b
#               (`decr a) 1)))
true;

# source: (assert 1000
#           (size b))
#   eval: (`assert 1000
#           (`size (`resolve b)))
true;

# source: (assert (del a))
#   eval: (`assert (`del a))
true;

# hash test
# source: (assert (del b))
#   eval: (`assert (`del b))
true;

# source: (assert (def main1 {}
#             [ (set n 1000), (set X {}),
#               (map (lambda null
#                   (set X
#                     (str _) _))
#                 (range 1
#                   (add n 1))),
#               (set c 0),
#               (map (lambda null
#                   (set c
#                     (add c
#                       (has X
#                         (str _)))))
#                 (range n 0 -1)),c]))
#   eval: (`assert (`def main1 {}
#             [ (`set n 1000), (`set X {}),
#               (`map (`lambda null
#                   (`set X
#                     (`str (`resolve _))
#                     (`resolve _)))
#                 (`range 1
#                   (`add (`resolve n) 1))),
#               (`set c 0),
#               (`map (`lambda null
#                   (`set c
#                     (`add (`resolve c)
#                       (`has X
#                         (`str (`resolve _))))))
#                 (`range (`resolve n) 0 -1)),
#               (`resolve c)]))
true;

# source: (assert (def main2 {}
#             [ (set X {}), (for (set i 0)
#                 (lt i 1000)
#                 (set i
#                   (add i 1))
#                 (set X
#                   (str i) i)),
#               (set c 0),
#               (for (set i 1000)
#                 (ge i 0)
#                 (set i
#                   (sub i 1))
#                 (set c
#                   (add c
#                     (has X
#                       (str i))))),c]))
#   eval: (`assert (`def main2 {}
#             [ (`set X {}), (`for (`set i 0)
#                 (`lt (`resolve i) 1000)
#                 (`set i
#                   (`add (`resolve i) 1))
#                 (`set X
#                   (`str (`resolve i))
#                   (`resolve i))),
#               (`set c 0),
#               (`for (`set i 1000)
#                 (`ge (`resolve i) 0)
#                 (`set i
#                   (`sub (`resolve i) 1))
#                 (`set c
#                   (`add (`resolve c)
#                     (`has X
#                       (`str (`resolve i)))))),
#               (`resolve c)]))
true;

# source: (assert 1000
#           (main1))
#   eval: (`assert 1000
#           [ (`resolve main1)])
true;

# source: (assert 1000
#           (main2))
#   eval: (`assert 1000
#           [ (`resolve main2)])
true;

# source: (assert (del main1))
#   eval: (`assert (`del main1))
true;

# confirm clean namespace
# source: (assert (del main2))
#   eval: (`assert (`del main2))
true;

# source: (assert {}
#           (symbols false))
#   eval: (`assert {}
#           (`symbols false))
true;

