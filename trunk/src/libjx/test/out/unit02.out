# unit02.jxp -- basic Python unit tests (no threads)
# simple assignment
# parsed: (set a 1)
# source: (set a 1)
#   eval: (`set a 1)
null;

# multiple assignment
# parsed: (map_set (a b)
#           [2, 1])
# source: (map_set (a b)
#           [2, 1])
#   eval: (`map_set (a b)
#           [2, 1])
null;

# parsed: (assert [2, 1]
#           (a b))
# source: (assert [2, 1]
#           (a b))
#   eval: (`assert [2, 1]
#           [ (`resolve a), (`resolve b)])
true;

# parsed: (map_set (a b)
#           (b a))
# source: (map_set (a b)
#           (b a))
#   eval: (`map_set (a b)
#           [ (`resolve b), (`resolve a)])
null;

# parsed: (assert [1, 2]
#           (a b))
# source: (assert [1, 2]
#           (a b))
#   eval: (`assert [1, 2]
#           [ (`resolve a), (`resolve b)])
true;

# we have literals 
# parsed: (set b {3:"some value", 8.4:0, "another key":"another value", "some key": [1, 2, 3]})
# source: (set b {3:"some value", 8.4:0, "another key":"another value", "some key": [1, 2, 3]})
#   eval: (`set b {3:"some value", 8.4:0, "another key":"another value", "some key": [1, 2, 3]})
null;

# parsed: (assert 4
#           (len b))
# source: (assert 4
#           (size b))
#   eval: (`assert 4
#           (`size (`resolve b)))
true;

# REMEMBER, Jenarix uses copy semantics, not reference-taking semantics, so
# parsed: (set d {"some key":"value"})
# source: (set d {"some key":"value"})
#   eval: (`set d {"some key":"value"})
null;

# NOTE: the following is a deep copy, not a reference copy!
# parsed: (set c d)
# source: (set c d)
#   eval: (`set c
#           (`resolve d))
null;

# parsed: (set (c "another key") "another_value")
# source: (set (c "another key") "another_value")
#   eval: (`set (c "another key") "another_value")
null;

# parsed: (print c)
# source: (print c)
#   eval: ( #native_fn`print (`resolve c))
{"some key":"value","another key":"another_value"}
null;

# parsed: (print d)
# source: (print d)
#   eval: ( #native_fn`print (`resolve d))
{"some key":"value"}
null;

# we have print
# parsed: (print "hello Python world!!! Can you hear me?")
# source: (print "hello Python world!!! Can you hear me?")
#   eval: ( #native_fn`print "hello Python world!!! Can you hear me?")
hello Python world!!! Can you hear me?
null;

# we have for loops (simple iterator)
# including multi-variable
# parsed: (foreach b
#           (range 3 8)
#           [ (print b)])
# source: (foreach b
#           (range 3 8)
#           [ (print b)])
#   eval: (`foreach b
#           (`range 3 8)
#           [ ( #native_fn`print (`resolve b))])
3
4
5
6
7
null;

Error: invalid syntax on line 50
    print a -->,<-- b
