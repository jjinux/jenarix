/* Generated by re2c 0.12.3 on Fri May 15 18:32:21 2009 */
#line 1 "jx_json_scan.re"
/* RE2C-based tokenizer */

#include <stdio.h>
#include <string.h>

#include "jx_json_private.h"

#define jx_os_read read
#define jx_os_sscanf sscanf
#define jx_os_fprintf fprintf
#define jx_os_strncpy strncpy

typedef jx_uint32 jx_size;
typedef jx_uint32 jx_uword;
typedef jx_int32  jx_word;

#define JX_JSON_SCANNER_MODE_STDIN  0
#define JX_JSON_SCANNER_MODE_STRING 1

typedef struct {
  jx_char *bot, *tok, *ptr, *cur, *pos, *lim, *top, *eof;
  jx_word line;
  jx_int mode; 
  jx_json_parse_context context;
} jx_json_scanner_state;

#ifndef true
#define true 1
#endif

#ifndef false
#define false 0
#endif

#define   BSIZE   8192

#define   YYCTYPE     jx_char
#define   YYCURSOR    cursor
#define   YYLIMIT     s->lim
#define   YYMARKER    s->ptr
#define   YYFILL(n)   {cursor = jx_fill(s, cursor);}

#define   RET(i)   {s->cur = cursor; return i;}

/* parser allocator */
static void *jx__json_alloc(jx_size bytes)
{
  jx_char *ptr = NULL;
  ptr = jx_calloc(1,bytes);
  return (void*)ptr;
}

static void jx__json_free(void *ptr)
{
  if(ptr) 
    jx_free(ptr);
}

static jx_size jx_read_stdin(jx_char *buf, jx_size buf_size)
{
  return fread((char*)buf, 1, buf_size, stdin);
}

static jx_char *jx_fill(jx_json_scanner_state *s, jx_char *cursor)
{
  switch(s->mode) {
  case JX_JSON_SCANNER_MODE_STDIN:
    if(!s->eof) {  
      jx_uword cnt = s->tok - s->bot; /* amount of open space in buffer */
      if(cnt) {
        if(s->lim > s->tok) { /* any remaining characters? */
          memcpy(s->bot, s->tok, s->lim - s->tok); /* move to start of buffer */
        }
        s->tok = s->bot;  /* shift pointers accordingly */
        s->ptr -= cnt; 
        cursor -= cnt;
        s->pos -= cnt;
        s->lim -= cnt;
      }
      if((s->top - s->lim) < BSIZE) { /* open space less than read quantum? */
        /* allocate a larger buffer */
        jx_char *buf = (jx_char*) jx_calloc(1,((s->lim - s->bot) +
                                               BSIZE)*sizeof(jx_char));
        if(buf) { /* and copy contents to new buffer */
          memcpy(buf, s->tok, s->lim - s->tok);
          s->tok = buf; /* adjust pointers accordingly */
          s->ptr = &buf[s->ptr - s->bot];
          cursor = &buf[cursor - s->bot];
          s->pos = &buf[s->pos - s->bot];
          s->lim = &buf[s->lim - s->bot];
          s->top = &s->lim[BSIZE];
          if(s->bot) { /* free old buffer (if exists) */
            jx_free(s->bot);
          }
          s->bot = buf; /* use the new buffer from now on */
        }
      }
      if((s->top - s->lim) < BSIZE) {
        /* unhandled error condition */
      } else {
        cnt = jx_read_stdin(s->lim, BSIZE);
        if(cnt != BSIZE) {
          jx_size cc = cnt;
          while(cc<BSIZE) {
            s->lim[cc] = 0;
            cc++;
          }
          s->eof = &s->lim[cnt]; 
          if(cnt) { 
            *(s->eof)++ = '\n';
          } else {
            *(s->eof)++ = 0;
          }
        }
        s->lim += cnt;
      }
    }
    break;
  }
  return cursor;
}
  
static int jx_scan(jx_json_scanner_state *s)
{
  jx_char *cursor = s->cur;
 std:
  s->tok = cursor;
  
  
#line 133 "<stdout>"
{
	YYCTYPE yych;
	unsigned int yyaccept = 0;

	if((YYLIMIT - YYCURSOR) < 5) YYFILL(5);
	yych = *YYCURSOR;
	switch(yych) {
	case 0x00:	goto yy26;
	case 0x09:
	case 0x0B:
	case 0x0C:
	case ' ':	goto yy24;
	case 0x0A:	goto yy30;
	case '"':	goto yy8;
	case '#':	goto yy28;
	case '+':
	case '-':	goto yy2;
	case ',':	goto yy17;
	case '.':	goto yy7;
	case '0':	goto yy4;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy6;
	case ':':	goto yy19;
	case '[':	goto yy9;
	case ']':	goto yy11;
	case 'f':	goto yy22;
	case 'n':	goto yy23;
	case 't':	goto yy21;
	case '{':	goto yy13;
	case '}':	goto yy15;
	default:	goto yy32;
	}
yy2:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch(yych) {
	case '.':	goto yy95;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy69;
	default:	goto yy3;
	}
yy3:
#line 175 "jx_json_scan.re"
	{
#ifdef JX_JSON_PARSER_DEBUG
      printf("unexpected character: %c\n", *s->tok);
#endif
       RET(JX_JSON_ERROR);
    }
#line 198 "<stdout>"
yy4:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	switch(yych) {
	case 'L':
	case 'U':
	case 'l':
	case 'u':	goto yy67;
	case 'X':
	case 'x':	goto yy88;
	default:	goto yy87;
	}
yy5:
#line 159 "jx_json_scan.re"
	{ RET(JX_JSON_ICON); }
#line 214 "<stdout>"
yy6:
	yyaccept = 1;
	yych = *(YYMARKER = ++YYCURSOR);
	goto yy70;
yy7:
	yych = *++YYCURSOR;
	switch(yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy59;
	default:	goto yy3;
	}
yy8:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch(yych) {
	case 0x00:
	case 0x0A:	goto yy3;
	default:	goto yy50;
	}
yy9:
	++YYCURSOR;
#line 147 "jx_json_scan.re"
	{ RET(JX_JSON_OPEN_RECT_BRACE); }
#line 246 "<stdout>"
yy11:
	++YYCURSOR;
#line 148 "jx_json_scan.re"
	{ RET(JX_JSON_CLOSE_RECT_BRACE); }
#line 251 "<stdout>"
yy13:
	++YYCURSOR;
#line 150 "jx_json_scan.re"
	{ RET(JX_JSON_OPEN_CURLY_BRACE); }
#line 256 "<stdout>"
yy15:
	++YYCURSOR;
#line 151 "jx_json_scan.re"
	{ RET(JX_JSON_CLOSE_CURLY_BRACE); }
#line 261 "<stdout>"
yy17:
	++YYCURSOR;
#line 153 "jx_json_scan.re"
	{ RET(JX_JSON_COMMA); }
#line 266 "<stdout>"
yy19:
	++YYCURSOR;
#line 154 "jx_json_scan.re"
	{ RET(JX_JSON_COLON); }
#line 271 "<stdout>"
yy21:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch(yych) {
	case 'r':	goto yy45;
	default:	goto yy3;
	}
yy22:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch(yych) {
	case 'a':	goto yy40;
	default:	goto yy3;
	}
yy23:
	yyaccept = 0;
	yych = *(YYMARKER = ++YYCURSOR);
	switch(yych) {
	case 'u':	goto yy35;
	default:	goto yy3;
	}
yy24:
	++YYCURSOR;
	yych = *YYCURSOR;
	goto yy34;
yy25:
#line 161 "jx_json_scan.re"
	{ goto std; }
#line 300 "<stdout>"
yy26:
	++YYCURSOR;
#line 163 "jx_json_scan.re"
	{ 
      if(cursor == s->eof) RET(JX_JSON_EOI);
    }
#line 307 "<stdout>"
yy28:
	++YYCURSOR;
#line 167 "jx_json_scan.re"
	{ goto comment; }
#line 312 "<stdout>"
yy30:
	++YYCURSOR;
#line 169 "jx_json_scan.re"
	{
      s->pos = cursor; s->line++;
      s->eof = NULL;
      goto std;
    }
#line 321 "<stdout>"
yy32:
	yych = *++YYCURSOR;
	goto yy3;
yy33:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy34:
	switch(yych) {
	case 0x09:
	case 0x0B:
	case 0x0C:
	case ' ':	goto yy33;
	default:	goto yy25;
	}
yy35:
	yych = *++YYCURSOR;
	switch(yych) {
	case 'l':	goto yy37;
	default:	goto yy36;
	}
yy36:
	YYCURSOR = YYMARKER;
	switch(yyaccept) {
	case 0: 	goto yy3;
	case 1: 	goto yy5;
	case 2: 	goto yy61;
	}
yy37:
	yych = *++YYCURSOR;
	switch(yych) {
	case 'l':	goto yy38;
	default:	goto yy36;
	}
yy38:
	++YYCURSOR;
#line 157 "jx_json_scan.re"
	{ RET(JX_JSON_NULL); }
#line 360 "<stdout>"
yy40:
	yych = *++YYCURSOR;
	switch(yych) {
	case 'l':	goto yy41;
	default:	goto yy36;
	}
yy41:
	yych = *++YYCURSOR;
	switch(yych) {
	case 's':	goto yy42;
	default:	goto yy36;
	}
yy42:
	yych = *++YYCURSOR;
	switch(yych) {
	case 'e':	goto yy43;
	default:	goto yy36;
	}
yy43:
	++YYCURSOR;
#line 156 "jx_json_scan.re"
	{ RET(JX_JSON_FALSE); }
#line 383 "<stdout>"
yy45:
	yych = *++YYCURSOR;
	switch(yych) {
	case 'u':	goto yy46;
	default:	goto yy36;
	}
yy46:
	yych = *++YYCURSOR;
	switch(yych) {
	case 'e':	goto yy47;
	default:	goto yy36;
	}
yy47:
	++YYCURSOR;
#line 155 "jx_json_scan.re"
	{ RET(JX_JSON_TRUE); }
#line 400 "<stdout>"
yy49:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy50:
	switch(yych) {
	case 0x00:
	case 0x0A:	goto yy36;
	case '"':	goto yy52;
	case '\\':	goto yy51;
	default:	goto yy49;
	}
yy51:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch(yych) {
	case '"':
	case '\'':
	case '?':
	case '\\':
	case 'a':
	case 'b':
	case 'f':
	case 'n':
	case 'r':
	case 't':
	case 'v':	goto yy49;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':	goto yy55;
	case 'x':	goto yy54;
	default:	goto yy36;
	}
yy52:
	++YYCURSOR;
#line 145 "jx_json_scan.re"
	{ RET(JX_JSON_SCON); }
#line 444 "<stdout>"
yy54:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch(yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':	goto yy57;
	default:	goto yy36;
	}
yy55:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch(yych) {
	case 0x00:
	case 0x0A:	goto yy36;
	case '"':	goto yy52;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':	goto yy55;
	case '\\':	goto yy51;
	default:	goto yy49;
	}
yy57:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch(yych) {
	case 0x00:
	case 0x0A:	goto yy36;
	case '"':	goto yy52;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':	goto yy57;
	case '\\':	goto yy51;
	default:	goto yy49;
	}
yy59:
	yyaccept = 2;
	YYMARKER = ++YYCURSOR;
	if((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = *YYCURSOR;
	switch(yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy59;
	case 'E':
	case 'e':	goto yy62;
	case 'F':
	case 'L':
	case 'f':
	case 'l':	goto yy63;
	default:	goto yy61;
	}
yy61:
#line 143 "jx_json_scan.re"
	{ RET(JX_JSON_FCON); }
#line 553 "<stdout>"
yy62:
	yych = *++YYCURSOR;
	switch(yych) {
	case '+':
	case '-':	goto yy64;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy65;
	default:	goto yy36;
	}
yy63:
	yych = *++YYCURSOR;
	goto yy61;
yy64:
	yych = *++YYCURSOR;
	switch(yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy65;
	default:	goto yy36;
	}
yy65:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch(yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy65;
	case 'F':
	case 'L':
	case 'f':
	case 'l':	goto yy63;
	default:	goto yy61;
	}
yy67:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch(yych) {
	case 'L':
	case 'U':
	case 'l':
	case 'u':	goto yy67;
	default:	goto yy5;
	}
yy69:
	yyaccept = 1;
	YYMARKER = ++YYCURSOR;
	if((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
	yych = *YYCURSOR;
yy70:
	switch(yych) {
	case '.':	goto yy71;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy69;
	case 'E':
	case 'e':	goto yy72;
	case 'L':
	case 'U':
	case 'l':
	case 'u':	goto yy67;
	default:	goto yy5;
	}
yy71:
	yyaccept = 2;
	yych = *(YYMARKER = ++YYCURSOR);
	switch(yych) {
	case 'E':
	case 'e':	goto yy78;
	default:	goto yy77;
	}
yy72:
	yych = *++YYCURSOR;
	switch(yych) {
	case '+':
	case '-':	goto yy73;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy74;
	default:	goto yy36;
	}
yy73:
	yych = *++YYCURSOR;
	switch(yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy74;
	default:	goto yy36;
	}
yy74:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch(yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy74;
	case 'F':
	case 'L':
	case 'f':
	case 'l':	goto yy63;
	default:	goto yy61;
	}
yy76:
	yyaccept = 2;
	YYMARKER = ++YYCURSOR;
	if((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = *YYCURSOR;
yy77:
	switch(yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy76;
	case 'E':
	case 'e':	goto yy82;
	case 'F':
	case 'L':
	case 'f':
	case 'l':	goto yy63;
	default:	goto yy61;
	}
yy78:
	yych = *++YYCURSOR;
	switch(yych) {
	case '+':
	case '-':	goto yy79;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy80;
	default:	goto yy36;
	}
yy79:
	yych = *++YYCURSOR;
	switch(yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy80;
	default:	goto yy36;
	}
yy80:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch(yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy80;
	case 'F':
	case 'L':
	case 'f':
	case 'l':	goto yy63;
	default:	goto yy61;
	}
yy82:
	yych = *++YYCURSOR;
	switch(yych) {
	case '+':
	case '-':	goto yy83;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy84;
	default:	goto yy36;
	}
yy83:
	yych = *++YYCURSOR;
	switch(yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy84;
	default:	goto yy36;
	}
yy84:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch(yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy84;
	case 'F':
	case 'L':
	case 'f':
	case 'l':	goto yy63;
	default:	goto yy61;
	}
yy86:
	yyaccept = 1;
	YYMARKER = ++YYCURSOR;
	if((YYLIMIT - YYCURSOR) < 4) YYFILL(4);
	yych = *YYCURSOR;
yy87:
	switch(yych) {
	case '.':	goto yy71;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy86;
	case 'E':
	case 'e':	goto yy72;
	case 'L':
	case 'U':
	case 'l':
	case 'u':	goto yy93;
	default:	goto yy5;
	}
yy88:
	yych = *++YYCURSOR;
	switch(yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':	goto yy89;
	default:	goto yy36;
	}
yy89:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch(yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':	goto yy89;
	case 'L':
	case 'U':
	case 'l':
	case 'u':	goto yy91;
	default:	goto yy5;
	}
yy91:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch(yych) {
	case 'L':
	case 'U':
	case 'l':
	case 'u':	goto yy91;
	default:	goto yy5;
	}
yy93:
	++YYCURSOR;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch(yych) {
	case 'L':
	case 'U':
	case 'l':
	case 'u':	goto yy93;
	default:	goto yy5;
	}
yy95:
	++YYCURSOR;
	switch((yych = *YYCURSOR)) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy59;
	default:	goto yy36;
	}
}
#line 182 "jx_json_scan.re"


  /* not used:
    "("         { RET(JX_JSON_OPENPAR); }
    ")"         { RET(JX_JSON_CLOSEPAR); }
    "."         { RET(JX_JSON_DOT); }
    L (L|D)*      { RET(JX_JSON_IDENT); }
    "`"         { RET(JX_JSON_BACKAPOSTROPHE); }

    ";"         { RET(JX_JSON_SEMICOLON); }

    "-"         { RET(JX_JSON_MINUS); }
    "+"         { RET(JX_JSON_PLUS); }
    (['] (ESC|any\[\n\\'])* [']) { RET(JX_JSON_SCON); }

    "="         { RET(JX_JSON_EQUALS); }
   */

comment:
  
#line 984 "<stdout>"
{
	YYCTYPE yych;
	if(YYLIMIT == YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch(yych) {
	case 0x00:	goto yy98;
	case 0x0A:	goto yy99;
	default:	goto yy101;
	}
yy98:
yy99:
	++YYCURSOR;
#line 203 "jx_json_scan.re"
	{ 
      s->pos = cursor; s->line++;
      s->eof = NULL;
      goto std; 
    }
#line 1003 "<stdout>"
yy101:
	++YYCURSOR;
#line 210 "jx_json_scan.re"
	{ goto comment; }
#line 1008 "<stdout>"
}
#line 211 "jx_json_scan.re"

  
}

#define SSCANF_BUFSIZE 32

/* anticipated use cases:
   (1) parsing a string buffer from memory
   (2) parsing from a file or file descriptor (e.g. stdin) 
   (3) parsing from a character stream 
*/

void jx_json_scan_input(jx_json_scanner_state *state)
{
  /* allocate parser */

  void *jx_Parser = jx_json_Alloc( (void *(*)(size_t))jx__json_alloc);

  jx_word tok_type;
  jx_char stack_buffer[SSCANF_BUFSIZE];

  while((tok_type = jx_scan(state)) != JX_JSON_EOI) {
    jx_ob token = JX_OB_NULL;
    jx_size st_len = state->cur - state->tok;
    
#ifdef JX_JSON_PARSER_DEBUG

    if(1) {
      jx_size i;
      jx_char *c = state->tok;
      
      if(st_len) {
        printf(" ");
        for(i=0;i<st_len;i++) {
          printf("%c",*(c++));
        }
        printf("\n");
      }
    }
#endif

    switch(tok_type) {
    case JX_JSON_ICON:
    case JX_JSON_FCON:
    case JX_JSON_SCON:
      {
        char *buffer = stack_buffer;
        if(st_len >= SSCANF_BUFSIZE) {
          buffer = jx_malloc(st_len+1);
        }
        if(buffer) {
          jx_os_strncpy(buffer, state->tok, st_len);                              
          buffer[st_len] = 0;
          switch(tok_type) {
          case JX_JSON_ICON:
            {
              int icon;/* eventually need to handle int32 vs. int64 */
              if( jx_os_sscanf(buffer, "%i", &icon) != 1) { /* use strtol instead? */
                icon = 0;
              }
              token = jx_ob_from_int(icon);            
            }
            break;
          case JX_JSON_FCON:
            {
#ifdef JX_64_BIT
              double fcon;
              if( jx_os_sscanf(buffer, "%lf", &fcon) != 1) { /* use strtof instead? */
                fcon = 0.0;
              }
#else
              float fcon; /* eventually need to handle float64 vs. float32 */
              if( jx_os_sscanf(buffer, "%f", &fcon) != 1) { /* use strtof instead? */
                fcon = 0.0F;
              }
#endif
              token = jx_ob_from_float(fcon);
            }
            break;
          case JX_JSON_SCON:
            buffer[st_len-1]=0;
            token = jx_ob_from_str(buffer+1);
            break;
          }
          if(buffer != stack_buffer)
            jx_free(buffer);
        }
        break;
      case JX_JSON_TRUE:
        token = jx_ob_from_bool(true);
        break;
      case JX_JSON_FALSE:
        token = jx_ob_from_bool(false);
        break;
      case JX_JSON_NULL:
        token = jx_ob_from_null();
        break;
      case JX_JSON_OPEN_RECT_BRACE:
      case JX_JSON_CLOSE_RECT_BRACE:
      case JX_JSON_OPEN_CURLY_BRACE:
      case JX_JSON_CLOSE_CURLY_BRACE:
      case JX_JSON_COMMA:
      case JX_JSON_EOI:
        /* do nothing */
        break;
      case JX_JSON_ERROR:
        state->context.status = -1;
        break;
      }
    }
    jx_json_(jx_Parser, (int)tok_type, token, &state->context);
    if(state->context.status<0) /* error */
      break;
  }

  /* parse end of input token */
  if(tok_type == JX_JSON_EOI) {
    jx_ob ob = JX_OB_NULL;
    jx_json_(jx_Parser, JX_JSON_EOI, ob, &state->context);
    jx_json_(jx_Parser, 0, ob, &state->context);
  }

  /* free the input buffer (if using stdin) */
  switch(state->mode) {
  case JX_JSON_SCANNER_MODE_STDIN:
    if(state->bot) 
      jx_free(state->bot);
    break;
  }
  /* free the parser instance */
  jx_json_Free(jx_Parser, jx__json_free);
}


jx_ob jx_ob_from_json_str(jx_char *st)
{
  jx_json_scanner_state state;
  jx_ob result = JX_OB_NULL;
  memset(&state,0,sizeof(state));
  state.cur = st;
  state.eof = st + strlen(st) + 1;
  state.mode = JX_JSON_SCANNER_MODE_STRING;
  jx_json_scan_input(&state);
  if(state.context.status==1) {
    result = state.context.result;
  }
  return result;
}

void jx_json_echo_stdin(void)
{
  jx_json_scanner_state state;
  memset(&state,0,sizeof(state));
  jx_json_scan_input(&state);
  if(state.context.status<0) {
    printf("syntax error.\n");
  } else {
    {
      jx_ob json = jx_ob_to_json(state.context.result);
      printf("%s\n",jx_ob_as_str(&json));
      jx_ob_free(json);
    }
    jx_ob_free(state.context.result);
  }
}
